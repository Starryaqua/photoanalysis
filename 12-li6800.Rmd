# LI-6800 的数据分析 {#anay_6800}

## 数据格式 {#data6800}

LI-6800 的数据前处理同 LI-6400 相同，如表 \@ref(tab:head6800) 所示的样式。

```{r, head6800, echo=FALSE}
style1 <- read.csv("./data/aci6800.csv")
knitr::kable(head(style1[, 1:6]),  longtable = TRUE, booktabs = TRUE, caption = '推荐 LI-6800 整理后数据样式')
```

## LI-6800 与 LI-6400 使用时的差别 {#dif}

`plantecophys` 使用时建立在 LI-6400XT 基础之上的软件包，因此在 LI-6800 代码中，需要改动的是 fitaci、fitacis 及 fitBB 中的 varnames 选项，也就是将 LI-6400XT 的表头改为 LI-6800 的表头。
以 fitaci 函数为例：

```{r, eval=FALSE}
 fitaci(aci, varnames = 
        list(ALEAF = "A", Tleaf = "Tleaf", Ci = "Ci", 
          PPFD  = "Qin", Rd = "Rd"))
```

## 光响应曲线注意事项 {#notice}

光响应曲线的拟合相对简单，仅需要光强和光合速率的值，其中需要修改的部分仅为光强的赋值部分，在文件名一致的前提下，修改如下代码即可：

```{r, eval=FALSE}
lrc_Q <- lrc$Qin
lrc_A <- lrc$A 
```

## LI-6800 RACiR\texttrademark 的测量与拟合 {#racir68}

在评估作物性状时，V$_{cmax}$ 及 J$_{max}$时非常有用，传统的 A–Ci 曲线测量要求植物叶片要在一定浓度 CO$_{2}$
下适应几分钟后完成测量，这样的测量有几个缺点：

* 测量时间长，一条曲线至少需要 20 – 30 min，样本量多，重复多时，这种方法几乎没有可行性。
* 整个测量过程中，时间长，酶的激活状态会有变化，叶绿体会移动，气孔的开度也会发生变化。

而 LI-6800 独有的 auto control 功能在算法上允许用户自定义 CO$_{2}$ 的起始浓度和种植浓度、变化方式（线性或其他）、所花费的时间，再加上其
IRGAs 极快的响应频率，使得短时间内的 A–Ci 的测量成为现实，即快速 CO$_{2}$ 响应曲线 RACiR\texttrademark
测量实验，该功能使得 5 min 内测量 A–Ci 曲线成为可能。该方法的实现可参考  @stinziano2017
的文章。

@stinziano2018 针对 RACiR\texttrademark 技术的疑问做了解答并提出了准确测量的建议，概括如下：

* 首先，采用 100 ppm/min 的变化速率是与标准方法重合度最高的测量。
* 其次，明确研究问题，目前已有研究表明Vcmax 与 Jmax 的计算结果与标准测量方法结果无显著差异。
* 任何条件的改变，都需要做空叶室校准，例如：流速，气体浓度变化方向、温度，斜率等。
* 空叶室校准与叶片测量采用严格的同一次校准，因为 IRGA  的漂移，需要再次匹配时，或者环境条件改变时，需要重新做空叶室校准。是否需要匹配，可通过不加叶片的最初状态查看，此时 A 值应接近为0，reference 和 sample 气体浓度读数接近相等。
* IRGA 分析器使用 5 此多项式进行校准，推荐使用 1 次到 5  次多项式进行拟合，然后根据 BIC 指数来确定最合适的空叶室校准系数（即非参数拟合的模型选择的问题）。
确定最合适的浓度变化范围。通常需要去掉最初和最后 30 s的数据。
* 最小化校准和测量值之间的水分摩尔分数差异。甚至有可能需要控制 reference 或 sample 的水的摩尔分数而不是 Vpdleaf。
通过预实验来确定最合适的 $CO_2$ 变化范围和随时间的斜率。

## racir 软件包实现 RACiR\texttrademark 数据分析  {#racir_pkg}

**可能软件包作者没有更改叶面积的需求，他的软件包只支持原始数据的处理，但这对有更改需求的客户来讲没那么友好，而且这样导致了大量代码的重复，我根据作者原来的代码，结合我自己数据分析的习惯，重新制作了一份软件包，下面代码实现是基于我的软件包实现的，如有需求，也可使用作者原来的代码实现**

```{r, racir_install, eval=FALSE}
devtools::install_github("zhujiedong/racir")
library(racir)
```

软件包的函数很多，但可以分为下面几类：

* 首先使用 `find_cut` 来查看使用数据的范围（排除野点）。

* 使用 `racircheck` 来检查校正数据 (非必须，但建议进行数据质量检查)

* 使用 `racircal` 进行数据的校准

### 实现过程 {#racir_pkg_real}

手上暂时没有原始数据格式的 racir 数据，因而现在使用以前的 csv 数据进行操作（空叶室测量数据和带叶片测量数据转为 csv 格式）。

首先检查空叶室校准：

```{r, racircheck, fig.cap="找出最合理的校准曲线数据范围"}
library(racir)
# only check the empty chamber data here
em1 <- read.csv("./data/racirem/em-1.csv")
le1 <- read.csv("./data/racirle/le-1.csv")
find_cut(em1)

```

上述代码查看参比室 $CO_2$ 浓度在两者之间的数据，确定后面代码使用的 `mincut`, `maxcut` 范围。此处我选择的范围如下问代码：

```{r, racircorpkg, fig.cap="校准曲线查看"}
racircheck(em1, mincut = 21 , maxcut = 463 )
```

没有问题可直接进行校准

```{r, racircor, fig.cap="校准后数据查看"}
x <- racircal(em1, le1, mincut = 21, maxcut = 463)
plot(x$CO2_r, x$A)
```
前两个参数分别为空叶室数据，带叶片测量数据，后面的最大最小值为 `racircheck` 确定，剩余工作就是使用 `plantecophys` 进行分析，在此不再重复这个过程。

**注意：RACiR 的本意是表型研究中求 Vcmax 和 Jmax，因而，请忽略 Rd 等参数的计算结果**

### 数据的批量处理 {#racirbatch}

#### readphoto 导入 {#imbyphoto}

如果数据的导入是使用 `readphoto` 批量处理，那么所在数据文件有 files 列，作为不同文件数据的区分，那么可以使用向量化处理方式实现数据的分析，参考如下代码：

```{r, eval=FALSE}
library(readphoto)
# read all empty data set
all_empty <- read_bat_6800("./empty_data")
# read all leaf data set
all_leaf <- read_bat_6800("./leaf_data")
listem  <-  split(all_empty, files)
listle <-  split(all_leaf, files)
cordata <- purrr::map2(listem, listle, racircal, mincut = 21, maxcut = 463)
```
所有的数据均保存在 cordata 中，特别注意 **此处要求 listem 与 listle 长度相同，因此，如果一个空叶室对多个带叶片测量数据，请将空叶室测量文件复制几份（注意对应顺序），使其每个带叶片测量的数据文件和空叶室测量数据文件数量相同，并且一一对应，例如 emtpy-1-1 数据文件对应 leaf-1-1**，文件命名前即制定好命名规则，方便后续数据处理。

#### 处理大量 csv 文件 {#imbycsv}

```{r, eval=FALSE}
# suppose leaf and empty data in 2 files in disk D:
le=list.files("d:/racirle/")
em=list.files("d:/racirem/")

# construct the path of these csv files
pathle = paste0("d:/racirle/", le)
pathem = paste0("d:/racirem/", em)

# import all leaf data and empty data separately
xx <- lapply(pathle, read.csv)
yy <- lapply(pathem, read.csv)

# correct all the data
all_correc <- purrr::map2(yy, xx, racircal, mincut = 21, maxcut=463)

#  export all data to csv files, these file have the same name with leaf data
dirc <- dir.create("d:/data/")
finame <- "d:/data/"
finame <- paste0(finame, le)
purrr::walk2(all_correc,  finame, write.csv)
```

以上代码仅供参考，主要是实现批量导入并校正，在批量将校正后数据导出为 csv 文件，为方便，将导出的文件名字命名为同原来带叶片测量数据相同的文件名，。

## 批量计算 $V_{cmax}$ 和 $J_max$ {#fitbatracir}

```{r, eval=FALSE}
#use csv data above
csvdata <- lapply(all_correc, plantecophys::fitaci, 
    varnames = list(ALEAF = "A", Tleaf = "Tleaf",
    Ci = "Ci", PPFD= "Q", Rd = "Rd"), fitmethod ="bilinear")

# use readphoto data above
photodata <- lapply(cordata, plantecophys::fitaci, 
    varnames = list(ALEAF = "A", Tleaf = "Tleaf",
    Ci = "Ci", PPFD= "Q", Rd = "Rd"), fitmethod ="bilinear")
```

批量分析同样使用向量化来进行，避免了循环，效率比较高，也可以将拟合结果 `coef` 中的 $V_{cmax}$ 和 $J_max$ 结果批量导入文件，参考 @\ref(imbycsv) 部分的代码。

## RACiR\texttrademark 分析的手动实现 {#racir68_exam}

以下内容是我之前写的内容，部分代码的实现和上述软件包相似，仅供参考，尤其是当您使用 `racir` 软件包报错时，可以参考下文代码手动实现 RACiR 数据的分析。

```{r, eval=FALSE}
# 分别读取未校准空叶室数据
# 未校准带叶片测量数据
# 标准aci曲线测量数据
uemp500 <- read.csv("./data/uncorr_emp500.csv")
uleaf500 <- read.csv("./data/uncorr_leaf500.csv")
acin <- read.csv("./data/aci_ex.csv")

# 防止读入空白行
m <- length(which(uemp500$obs >= 1))
n <- length(which(uleaf500$obs >= 1))
uemp500 <- uemp500[1:m,]
uleaf500 <- uleaf500[1:n,]

# 观察空叶室未校准数据reference对A的图形
plot(uemp500$CO2_r, uemp500$A)
# 选取线性部分用于校准
locator()
# 执行locator命令后，在上图中的目标位置选点，
# 选好后按 esc 可以返回所选点的坐标（选点即为在
# 预期位置鼠标单击）

# 根据上面的点，利用二氧化碳的值过滤掉不需要的数据
# 只要在线性范围内选点，拟合结果相差很小
cemp <- uemp500[which(uemp500$CO2_r > 
                        45.28 & uemp500$CO2_r < 459.12),]
plot(cemp$CO2_r, cemp$A)

# 采用 1~5 次多项式分别拟合
cal1st <- lm(A ~ CO2_r, data = cemp)
cal2nd <- lm(A ~ poly(CO2_r, 2), data = cemp)
cal3rd <- lm(A ~ poly(CO2_r, 3), data = cemp)
cal4th <- lm(A ~ poly(CO2_r, 4), data = cemp)
cal5th <- lm(A ~ poly(CO2_r, 5), data = cemp)

# 利用 BIC 找出最合理的校准方程
bics <- BIC(cal1st, cal2nd, cal3rd, cal4th, cal5th)
# noquote也就是没引号，成为名字
best <- noquote(rownames(bics)[bics$BIC == min(bics$BIC)])
best

# 校准带叶片测量的数据
uleafc <- uleaf500
uleafc$A <- uleafc$A - predict(cal4th, uleafc)
uleafc$Ci <- ((uleafc$gtc - uleafc$E / 2) * uleafc$CO2_s - 
                uleafc$A) / (uleafc$gtc + uleafc$E / 2)

# 对校准前后的数据进行作图，查看校准效果
plot(uleaf500$CO2_r, uleaf500$A, pch = 2, ylim = c(-20, 40))
points(uleafc$CO2_r, uleafc$A)
locator()
cleaf <- uleafc[which(uleafc$CO2_r > 16.6 & 
                        uleafc$CO2_r < 478),]
plot(cleaf$CO2_r, cleaf$A)

# 利用plantecophys拟合标准曲线和racir曲线
library("plantecophys")
acifit <- fitaci(cleaf, varnames = 
                   list(ALEAF = "A", Tleaf = "Tleaf", Ci = "Ci", 
                        PPFD  = "Qin", Rd = "Rd"), Patm = 84.09)
acifit_normal <- fitaci(acin, varnames = 
                          list(ALEAF = "A", Tleaf = "Tleaf", Ci = "Ci", 
                               PPFD  = "Qin", Rd = "Rd"), Patm = 84.09)
# 查看拟合数据
acifit$pars
acifit_normal$pars

# 对快速曲线作图拟合结果进行查看
plot(acifit, linecols = c("green", "blue", "red"))

#### ggplot2 作图
ddata <- acifit$df

alldata <- data.frame(A = c(acin$A, ddata$Ac, ddata$Aj, cleaf$A), 
                      Ci = c(acin$Ci, ddata$Ci, ddata$Ci, cleaf$Ci),
                      Atype = c(
                        rep("standard Aci curve", length(acin$A)),
                        rep("Ac", length(ddata$Ac)), 
                        rep("Aj", length(ddata$Aj)),
                        rep("A corrected", length(cleaf$A))
                      )
)

alldata$Atype <- factor(alldata$Atype, 
                        levels = c("standard Aci curve", 
                                   "Ac", "Aj", "A corrected"))

library(ggplot2)
p <- ggplot(alldata)
p1 <- p + geom_point(aes(Ci,A, colour = Atype),  alpha = 0.5)

p2 <- p1 + geom_smooth(aes(Ci, A, colour = Atype),
                       method = 'auto') + 
  labs(y=expression(paste("A ", "(", mu, 
                          mol%.%m^-2%.%s^-1, ")")), 
       x=expression(paste(C[i], " ",
                          "(", mu, mol%.%mol^-1, ")")))

p2 + scale_x_continuous(limits=c(0, 1800),
                        breaks=seq(0, 1800, 200)) +  
  scale_y_continuous(limits=c(-3, 50),
                     breaks=seq(0, 50, 10)) + 
  scale_colour_hue(name="  ", 
                   labels=c('ACi curve data; ', 
                            expression(paste(A[c], ' data; ')), 
                            expression(paste(A[j], ' data; ')), 
                            'RACiR data') 
  ) + theme_set(theme_bw()) +
  theme(axis.text.x  = element_text(size = 10, 
                                    angle=30, vjust=0.5), 
        axis.text.y = element_text(size = 10),
        axis.title.x = element_text(
          size = 12, face = 'bold'),
        axis.title.y = element_text(
          size = 12, face = 'bold'),
        legend.text.align = 0,
        legend.position = c(0.8, 0.6))
```

最终采用常规方法和 RACiR\texttrademark 方法结果如图 \@ref(fig:racir) 所示，其中 Aj 与 Ac 结果采用 RACiR\texttrademark 计算^[注意，注意数据表头的大小写，此处代码中，为处理数据的方便，我更改了大小写，分析自己的数据时需要注意]。
```{r, racir, out.width='100%', fig.cap = "RACiR 方法与常规结果的比较", echo = FALSE}
knitr::include_graphics("images/racir.png")
```

## 利用不同速率的 RACiR 曲线研究植物的光合生理特性 {#multirate-racir}

自 RACiR 技术诞生以来，极大的缩短了 Vcmax 以及 Jmax 的测量时间(@stinziano2017)，但也引起了一系列争议，作者也对业内的质疑进行了一一的解答 (@stinziano2018)，但除了因为时间长短导致酶活性，叶绿体位置等差异外，RACiR 还能说明哪些问题呢？@stinziano2019 最新的研究给出一系列结论：

* 扩散限制（$CO_2$ 总导度） 和光呼吸导致了表观上的标准 ACi 曲线和 RACiR 测量之间的偏差，表明他们的差异是由**生物因子引起，而非仪器导致的人为误差**。

* 上述原因导致的二者之间的偏差，如果不进行修正，那么将显著的低估 $\Gamma^*$, 除非使用多个速率的 RACiR 来修正。

* 较高速率的 RACiR 曲线会增大其与标准曲线之间的偏差，但这个差距在无光呼吸的条件下会减小。

* 因为光呼吸和气体扩散限制与物种相关，结合以上结论，可以使用多个速率的 RACiR 来估算对 $CO_2$ 的总导度以及相对量的光呼吸速率。

一些可能的方向：

* 扩散限制影响 Cc 速率的变化，说明对具有较高总阻力与 $CO_2$ 比值的物种，例如针叶物种，C4 植物，较高的阻力导致 RACiR 与 标准 ACi 测量斜率更大的差异，或者测量的前提假设被破坏。

* RACiR 可检测到代谢中 $CO_2$ 的滞后性，各种滞后性的检测对标准 ACi 测量也具有指示性。

文中利用 R 实现了光呼吸之后模型和气体扩散限制模型，本文内容主要对文献中附录材料的源码进行解释：

### 光呼吸滞后模型 {#photoresp-lag}

为测试光呼吸的滞后性，作者使用一系列预先设定的参数，模拟了一条 ACc曲线，假定 Rubisco 激活状态为 100%，并且在整个测量过程中气孔导度是不变的。然后使用这些参数来模拟 RACiRs 曲线，并且假定光呼吸分别需要 0, 15, 30, 60, 120 或 300 s 来对变化的 $CO_2$ 进行响应，在实际效果上，这意味着 Cc 在最初的 0, 15, 30, 60, 120 或 300 内是不变的，最后我们对 $\Gamma^*$ 和 Ci 使用线性回归进行计算。

#### 基础数据 {#base-data}

模型第一步，则是对需要使用的参数，根据文献和实际情况进行赋值，具体内容参考代码注释。

```{r}
library(ggplot2)
library(plyr)
library(gridExtra)

# 对图例使用自定义颜色
gg_color_hue <- function(n) {
  hues = seq(15, 375, length = n + 1)
  hcl(h = hues, l = 65, c = 100)[1:n]
}

#Maximum Rubisco carboxylation rate in umol m-2 s-1
Vcmax <- 110

#Maximum Rubisco oxygenation rate in umol m-2 s-1;
#Ratio from Bernacchi et al. 2001. PCE 24:253-259
Vomax <- 0.29 * Vcmax
#Dark respiration in umol m-2 s-1
R <- 2
#Michaelis-Menten constant for Rubisco carboxylation in umol mol-1
Kc <- 404.9
#Michaelis-Menten constant for Rubisco oxygenation in mmol mol-1
Ko <- 278.4
#oxygen concentration in mmol mol-1
O2 <- 210
Kco <- Kc * (1 + O2 / Ko)
#Boundary layer conductance in mol m-2 s-1
BLC <- 2
#stomatal conductance in mol m-2 s-1
gsw <- 0.4
#mesophyll conductance in mol m-2 s-1
gm <- 1
#Chloroplastic CO2 in umol mol-1
Cc <- as.numeric(c(25:400))
#oxygenation rate in umol m-2 s-1
vo <- Vomax * O2 / (O2 + Ko * (1 + Cc / Kc))
#carboxylation rate in umol m-2 s-1
vc <- Vcmax * (Cc) / (Cc + Kco)
#Net CO2 assimilation in umol m-2 s-1
A <- vc - 0.5 * vo - R
#Apparent CO2 assimilation rate in umol m-2 s-1
Aapparent <- vc - 0.5 * vo
#Intercellular CO2 in umol mol-1
Ci <- A / gm + Cc
#Boundary layer CO2 in umol mol-1
Cb <- A / gsw + Ci
#Reference CO2 in umol mol-1
Cr <- A / BLC + Cb

#根据Cc浓度的个数，构造向量
Counter <- as.numeric(c(1:length(Cc)))
#也就是以秒计算的cr与时间的模型
RateCrmodel <- lm(Cr ~ Counter)
#转化为分钟的cr的斜率
RateCr <- coef(RateCrmodel)[2] * 60

#转换为分钟的边界层导度斜率
RateCbmodel <- lm(Cb ~ Counter)
RateCb <- coef(RateCbmodel)[2] * 60

#转换为分钟的ci的斜率
RateCimodel <- lm(Ci ~ Counter)
RateCi <- coef(RateCimodel)[2] * 60

#转换为分钟的Cc的斜率
RateCcmodel <- lm(Cc ~ Counter)
RateCc <- coef(RateCcmodel)[2] * 60 
```

### 光呼吸滞后性代码 {code-photoresp}

下面代码的目的是为得到 ACi 响应曲线受光呼吸延迟的影响，尤其是在临近补偿点时。

**延迟模块**

```{r}
#假定有15s延迟时的数据，即相比上面构造的Cc数据减少15个点
Cc15 <- as.numeric(c((min(Cc) + 15):max(Cc), rep(max(Cc), 15)))
vo15 <- Vomax * O2 / (O2 + Ko * (1 + Cc15 / Kc))
A15 <- vc - 0.5 * vo15 - R
Aapparent15 <- vc - 0.5 * vo15

#30 s 延迟数据
Cc30 <- as.numeric(c((min(Cc) + 30):max(Cc), rep(max(Cc), 30)))
vo30 <- Vomax * O2 / (O2 + Ko * (1 + Cc30 / Kc))
A30 <- vc - 0.5 * vo30 - R
Aapparent30 <- vc - 0.5 * vo30

#60s 延迟数据
Cc60 <- as.numeric(c((min(Cc) + 60):max(Cc), rep(max(Cc), 60)))
vo60 <- Vomax * O2 / (O2 + Ko * (1 + Cc60 / Kc))
A60 <- vc - 0.5 * vo60 - R
Aapparent60 <- vc - 0.5 * vo60

#120s延迟数据
Cc120 <- as.numeric(c((min(Cc) + 120):max(Cc), rep(max(Cc), 120)))
vo120 <- Vomax * O2 / (O2 + Ko * (1 + Cc120 / Kc))
A120 <- vc - 0.5 * vo120 - R
Aapparent120 <- vc - 0.5 * vo120

#300s延迟数据
Cc300 <- as.numeric(c((min(Cc) + 300):max(Cc), rep(max(Cc), 300)))
vo300 <- Vomax * O2 / (O2 + Ko * (1 + Cc300 / Kc))
A300 <- vc - 0.5 * vo120 - R
Aapparent300 <- vc - 0.5 * vo300 
```

### 数据的构造 {#compi-modu}

下面的代码主要是将上文最终计算的数据构造数据集，并导出。

```{r}
Anet <- c(A, A15, A30, A60, A120, A300)
Aapp <-
  c(Aapparent,
    Aapparent15,
    Aapparent30,
    Aapparent60,
    Aapparent120,
    Aapparent300)
Ccfull <- rep(Cc, 6)
Cifull <- rep(Ci, 6)
Delay <-
  c(
    rep("0", length(A)),
    rep("15", length(A15)),
    rep("30", length(A30)),
    rep("60", length(A60)),
    rep("120", length(A120)),
    rep("300", length(A300))
  )
PRdata <- as.data.frame(cbind(Anet, Aapp, Ccfull, Cifull, Delay))
write.csv(PRdata, "./data/PRdata.csv")
```

### 光呼吸滞后性作图 {#photo-resp-graph}

下面的代码是将光呼吸的数据进行作图。

```{r, anetcc, fig.cap = "Anet VS. Cc", message=FALSE}
data <- read.csv("./data/PRdata.csv")
data$Ccfull <- as.numeric(data$Ccfull)
data$Delay <- as.factor(data$Delay)

# 净光合速率与Cc作图
AnetCc <- ggplot(data, aes(x = Ccfull, y = Anet, colour = Delay)) +
  geom_point() +
  labs(x = expression(C[c] ~ "(" * mu * mol ~ mol ^ {
    -1
  } * ")"),
  y = expression(A[net] ~ "(" * mu * mol ~ m ^ {
    -2
  } ~ s ^ {
    -1
  } * ")")) +
  labs(colour = 'Delay (s)') +
  scale_x_continuous(limits = c(25, 100),
                     breaks = c(25, 40, 55, 70, 85, 100)) +
  scale_y_continuous(limits = c(-5, 5)) +
  scale_colour_brewer(palette = 'Spectral') +
  #补偿点的参考线
  geom_hline(yintercept = 0) +
  theme_bw() +
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank())
AnetCc
```

```{r, anetci, fig.cap = "Anet VS. Ci", message=FALSE}
#净光合速率与Ci作图
AnetCi <- ggplot(data, aes(x = Cifull, y = Anet, colour = Delay)) +
  geom_point() +
  labs(x = expression(C[i] ~ "(" * mu * mol ~ mol ^ {
    -1
  } * ")"),
  y = expression(A[net] ~ "(" * mu * mol ~ m ^ {
    -2
  } ~ s ^ {
    -1
  } * ")")) +
  labs(colour = 'Delay (s)') +
  scale_x_continuous(limits = c(25, 100),
                     breaks = c(25, 40, 55, 70, 85, 100)) +
  scale_y_continuous(limits = c(-5, 5)) +
  scale_colour_brewer(palette = 'Spectral') +
  geom_hline(yintercept = 0) +
  theme_bw() +
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank())
AnetCi
```

```{r, aappcc, fig.cap = "Aapparent VS. Cc", message=FALSE}
#表观光合与Cc作图
AappCc <- ggplot(data, aes(x = Ccfull, y = Aapp, colour = Delay)) +
  geom_point() +
  labs(x = expression(C[c] ~ "(" * mu * mol ~ mol ^ {
    -1
  } * ")"),
  y = expression(A[apparent] ~ "(" * mu * mol ~ m ^ {
    -2
  } ~ s ^ {
    -1
  } * ")")) +
  labs(colour = 'Delay (s)') +
  scale_x_continuous(limits = c(25, 75),
                     breaks = c(25, 35, 45, 55, 65, 75)) +
  scale_y_continuous(limits = c(-5, 5)) +
  scale_colour_brewer(palette = 'Spectral') +
  geom_hline(yintercept = 0) +
  theme_bw() +
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank())
AappCc
```

```{r, aappci, fig.cap = "Aapparent VS. Ci", message=FALSE}
#表观与Ci作图
AappCi <- ggplot(data, aes(x = Cifull, y = Aapp, colour = Delay)) +
  geom_point() +
  labs(x = expression(C[i] ~ "(" * mu * mol ~ mol ^ {
    -1
  } * ")"),
  y = expression(A[apparent] ~ "(" * mu * mol ~ m ^ {
    -2
  } ~ s ^ {
    -1
  } * ")")) +
  labs(colour = 'Delay (s)') +
  scale_x_continuous(limits = c(25, 75),
                     breaks = c(25, 35, 45, 55, 65, 75)) +
  scale_y_continuous(limits = c(-5, 5)) +
  scale_colour_brewer(palette = 'Spectral') +
  geom_hline(yintercept = 0) +
  theme_bw() +
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank())
AappCi
```

### 补偿点计算 {#gammastar}

计算不同的光呼吸时间延迟下的补偿点（基于Ci）：

```{r}
#对于基于Ci的数据，仅采用ci<100时的数据
dataCi <- data[data$Cifull < 100,]
dataCi0 <- dataCi[dataCi$Delay == "0",]
dataCi15 <- dataCi[dataCi$Delay == "15",]
dataCi30 <- dataCi[dataCi$Delay == "30",]
dataCi60 <- dataCi[dataCi$Delay == "60",]
dataCi120 <- dataCi[dataCi$Delay == "120",]
dataCi300 <- dataCi[dataCi$Delay == "300",]

#光呼吸无延迟时的计算，线性拟合
m1 <- lm(dataCi0$Anet ~ dataCi0$Cifull)
summary(m1)
#补偿点为截距比斜率（纵坐标为零）
Gamma0 <- -m1$coefficients[1] / m1$coefficients[2]

#光呼吸延时15s
m2 <- lm(dataCi15$Anet ~ dataCi15$Cifull)
summary(m2)
Gamma15 <- -m2$coefficients[1] / m2$coefficients[2]

#光呼吸延时30s
m3 <- lm(dataCi30$Anet ~ dataCi30$Cifull)
summary(m3)
Gamma30 <- -m3$coefficients[1] / m3$coefficients[2]

#光呼吸延时60s
m4 <- lm(dataCi60$Anet ~ dataCi60$Cifull)
summary(m4)
Gamma60 <- -m4$coefficients[1] / m4$coefficients[2]

#光呼吸延时120s
m5 <- lm(dataCi120$Anet ~ dataCi120$Cifull)
summary(m5)
Gamma120 <- -m5$coefficients[1] / m5$coefficients[2]

#光呼吸延时300s
m6 <- lm(dataCi300$Anet ~ dataCi300$Cifull)
summary(m6)
Gamma300 <- -m6$coefficients[1] / m6$coefficients[2]
```

构造数据并作图
```{r, intdelay, fig.cap = "基于 Ci 的不同延时下的截距", message=FALSE}
GammaCi <- c(Gamma0, Gamma15, Gamma30, Gamma60, Gamma120, Gamma300)

ints <-
  c(
    m1$coefficients[1],
    m2$coefficients[1],
    m3$coefficients[1],
    m4$coefficients[1],
    m5$coefficients[1],
    m6$coefficients[1]
  )
slps <-
  c(
    0,
    m2$coefficients[2] - m1$coefficients[2],
    m3$coefficients[2] - m1$coefficients[2],
    m4$coefficients[2] - m1$coefficients[2],
    m5$coefficients[2] - m1$coefficients[2],
    m6$coefficients[2] - m1$coefficients[2]
  )
dels <- c(0, 15, 30, 60, 120, 300)
summary(lm(ints ~ dels))
plot(ints ~ dels)
```


```{r, intslps, fig.cap = "基于 Ci 的不同延时下的斜率变化", message=FALSE}
plot(slps ~ dels)
summary(lm(slps ~ dels - 1))
```

基于 Cc 的补偿点计算结果:

```{r}
# 仅使用 Cc < 75的数据点拟合，过程同ci
dataCc <- data[data$Ccfull < 75, ]
dataCc0 <- dataCc[dataCc$Delay == "0", ]
dataCc15 <- dataCc[dataCc$Delay == "15", ]
dataCc30 <- dataCc[dataCc$Delay == "30", ]
dataCc60 <- dataCc[dataCc$Delay == "60", ]
dataCc120 <- dataCc[dataCc$Delay == "120", ]
dataCc300 <- dataCc[dataCc$Delay == "300", ]

# 无延迟数据
m1 <- lm(dataCc0$Anet ~ dataCc0$Ccfull)
summary(m1)
Gamma0 <- -m1$coefficients[1] / m1$coefficients[2]

#延时15s数据
m2 <- lm(dataCc15$Anet ~ dataCc15$Ccfull)
summary(m2)
Gamma15 <- -m2$coefficients[1] / m2$coefficients[2]

#延时30s数据
m3 <- lm(dataCc30$Anet ~ dataCc30$Ccfull)
summary(m3)
Gamma30 <- -m3$coefficients[1] / m3$coefficients[2]

#延时60s数据
m4 <- lm(dataCc60$Anet ~ dataCc60$Ccfull)
summary(m4)
Gamma60 <- -m4$coefficients[1] / m4$coefficients[2]

#延时120s数据
m5 <- lm(dataCc120$Anet ~ dataCc120$Ccfull)
summary(m5)
Gamma120 <- -m5$coefficients[1] / m5$coefficients[2]

#延时300s数据
m6 <- lm(dataCc300$Anet ~ dataCc300$Ccfull)
summary(m6)
Gamma300 <- -m6$coefficients[1] / m6$coefficients[2]
```

```{r, intdelaycc, fig.cap = "基于 Cc 的不同延时下的时间", message=FALSE}
GammaCc <- c(Gamma0, Gamma15, Gamma30, Gamma60, Gamma120, Gamma300)

ints <-
  c(
    m1$coefficients[1],
    m2$coefficients[1],
    m3$coefficients[1],
    m4$coefficients[1],
    m5$coefficients[1],
    m6$coefficients[1]
  )
dels <- c(0, 15, 30, 60, 120, 300)
plot(ints ~ dels)
summary(lm(ints ~ dels))
```

```{r, slpdelaycc, fig.cap = "基于 Cc 的不同延时下的截距", message=FALSE}
#GammaStar
# For Ci-based estimates, only use Ci < 100
dataCi <- data[data$Cifull < 100,]
dataCi0 <- dataCi[dataCi$Delay == "0",]
dataCi15 <- dataCi[dataCi$Delay == "15",]
dataCi30 <- dataCi[dataCi$Delay == "30",]
dataCi60 <- dataCi[dataCi$Delay == "60",]
dataCi120 <- dataCi[dataCi$Delay == "120",]
dataCi300 <- dataCi[dataCi$Delay == "300",]
m1 <- lm(dataCi0$Aapp ~ dataCi0$Cifull)
summary(m1)
Gamma0 <- -m1$coefficients[1] / m1$coefficients[2]
m2 <- lm(dataCi15$Aapp ~ dataCi15$Cifull)
summary(m2)
Gamma15 <- -m2$coefficients[1] / m2$coefficients[2]
m3 <- lm(dataCi30$Aapp ~ dataCi30$Cifull)
summary(m3)
Gamma30 <- -m3$coefficients[1] / m3$coefficients[2]
m4 <- lm(dataCi60$Aapp ~ dataCi60$Cifull)
summary(m4)
Gamma60 <- -m4$coefficients[1] / m4$coefficients[2]
m5 <- lm(dataCi120$Aapp ~ dataCi120$Cifull)
summary(m5)
Gamma120 <- -m5$coefficients[1] / m5$coefficients[2]
m6 <- lm(dataCi300$Aapp ~ dataCi300$Cifull)
summary(m6)
Gamma300 <- -m6$coefficients[1] / m6$coefficients[2]

GammastarCi <-
  c(Gamma0, Gamma15, Gamma30, Gamma60, Gamma120, Gamma300)

# For Cc-based estimates, only use Cc < 75
dataCc <- data[data$Ccfull < 75,]
dataCc0 <- dataCc[dataCc$Delay == "0",]
dataCc15 <- dataCc[dataCc$Delay == "15",]
dataCc30 <- dataCc[dataCc$Delay == "30",]
dataCc60 <- dataCc[dataCc$Delay == "60",]
dataCc120 <- dataCc[dataCc$Delay == "120",]
dataCc300 <- dataCc[dataCc$Delay == "300",]
m1 <- lm(dataCc0$Aapp ~ dataCc0$Ccfull)
summary(m1)
Gamma0 <- -m1$coefficients[1] / m1$coefficients[2]
m2 <- lm(dataCc15$Aapp ~ dataCc15$Ccfull)
summary(m2)
Gamma15 <- -m2$coefficients[1] / m2$coefficients[2]
m3 <- lm(dataCc30$Aapp ~ dataCc30$Ccfull)
summary(m3)
Gamma30 <- -m3$coefficients[1] / m3$coefficients[2]
m4 <- lm(dataCc60$Aapp ~ dataCc60$Ccfull)
summary(m4)
Gamma60 <- -m4$coefficients[1] / m4$coefficients[2]
m5 <- lm(dataCc120$Aapp ~ dataCc120$Ccfull)
summary(m5)
Gamma120 <- -m5$coefficients[1] / m5$coefficients[2]
m6 <- lm(dataCc300$Aapp ~ dataCc300$Ccfull)
summary(m6)
Gamma300 <- -m6$coefficients[1] / m6$coefficients[2]

GammastarCc <-
  c(Gamma0, Gamma15, Gamma30, Gamma60, Gamma120, Gamma300)

Delay2 <- c("0", "15", "30", "60", "120", "300")
PRcomps <-
  as.data.frame(cbind(Delay2, GammaCc, GammaCi, GammastarCc, GammastarCi))
write.csv(PRcomps, "./data/PRcomps.csv")

ints <-
  c(
    m1$coefficients[1],
    m2$coefficients[1],
    m3$coefficients[1],
    m4$coefficients[1],
    m5$coefficients[1],
    m6$coefficients[1]
  )
dels <- c(0, 15, 30, 60, 120, 300)
summary(lm(ints ~ dels))
plot(ints ~ dels)
```

### 无光呼吸酶失活模块 {#no-phoresp-rubi}

该部分内容是在测量 ACi 曲线时检测 Rubisco 失活的影响 -- 从激活状态的变化导致了多少的偏移？

#### 数据构造 {#data-pre}

基于文献，假定 $CO_2$ 从 400 ppm 降低至 5 ppm 时，激活率从 100% 降低至 80%。

```{r}
#Assume that Rubisco activation state drops from 100% at 400 ppm to 80% at 5 ppm Cr (line 273 is Cr of 400, Cc of 297; 5ppm Cr is 25 ppm Cc) roughly from Salvucci et al 1986, arabidopsis; assume linear response

#不同的cr对应了不同的cc浓度，
#此为cc的变化范围（cr从400降低至5）
ccslope <- c(25, 297)
#酶的激活率变化
raslope <- c(0.80, 1.00)
#得到cc变化对应rubisco激活率变化的关系
ram1 <- lm(raslope ~ ccslope)
raslope <- coef(ram1)[2]
raint <- coef(ram1)[1]

#根据公式计算酶部分失活后各个参数
vora1 <- (raslope * Cc + raint) * Vomax * O2 / (O2 + Ko * (1 + Cc / Kc))
vcra1 <- (raslope * Cc + raint) * Vcmax * (Cc) / (Cc + Kco)
Ara1 <- vcra1 - 0.5 * vora1 - R
Aapparentra1 <- vcra1 - 0.5 * vora1
Cira1 <- Ara1 / gm + Cc
Cbra1 <- Ara1 / gsw + Cira1
Crra1 <- Ara1 / BLC + Cbra1

#失活后换算为分钟的变化斜率
Counter <- as.numeric(c(1:length(Cc)))
RateCr1model <- lm(Crra1 ~ Counter)
RateCr1 <- coef(RateCr1model)[2] * 60
RateCb1model <- lm(Cbra1 ~ Counter)
RateCb1 <- coef(RateCb1model)[2] * 60
RateCi1model <- lm(Cira1 ~ Counter)
RateCi1 <- coef(RateCi1model)[2] * 60
RateCcmodel <- lm(Cc ~ Counter)
RateCc <- coef(RateCcmodel)[2] * 60

#假定在5ppm时下降为40%
ccslope2 <- c(25, 297)
raslope2 <- c(0.40, 1.00)
ram2 <- lm(raslope2 ~ ccslope2)
raslope2 <- coef(ram2)[2]
raint2 <- coef(ram2)[1]

vora2 <-
  (raslope2 * Cc + raint2) * Vomax * O2 / (O2 + Ko * (1 + Cc / Kc)) 
vcra2 <- (raslope2 * Cc + raint2) * Vcmax * (Cc) / (Cc + Kco) 
Ara2 <- vcra2 - 0.5 * vora2 - R 
Aapparentra2 <- vcra2 - 0.5 * vora2 
Cira2 <- Ara2 / gm + Cc #umol mol-1
Cbra2 <- Ara2 / gsw + Cira2 #umol mol-1
Crra2 <- Ara2 / BLC + Cbra2 #umol mol-1
Counter <- as.numeric(c(1:length(Cc)))
RateCr2model <- lm(Crra2 ~ Counter)
RateCr2 <- coef(RateCr2model)[2] * 60 #umol mol-1 min-1
RateCb2model <- lm(Cbra2 ~ Counter)
RateCb2 <- coef(RateCb2model)[2] * 60 #umol mol-1 min-1
RateCi2model <- lm(Cira2 ~ Counter)
RateCi2 <- coef(RateCi2model)[2] * 60 #umol mol-1 min-1
RateCcmodel <- lm(Cc ~ Counter)
RateCc <- coef(RateCcmodel)[2] * 60 #umol mol-1 min-1

#假定在5ppm时下降为20%
ccslope3 <- c(25, 297)
raslope3 <- c(0.20, 1.00)
ram3 <- lm(raslope3 ~ ccslope3)
raslope3 <- coef(ram3)[2]
raint3 <- coef(ram3)[1]

vora3 <-
  (raslope3 * Cc + raint3) * Vomax * O2 / (O2 + Ko * (1 + Cc / Kc)) 
vcra3 <- (raslope3 * Cc + raint3) * Vcmax * (Cc) / (Cc + Kco) 
Ara3 <- vcra3 - 0.5 * vora3 - R 
Aapparentra3 <- vcra3 - 0.5 * vora3 
Cira3 <- Ara3 / gm + Cc 
Cbra3 <- Ara3 / gsw + Cira3 
Crra3 <- Ara3 / BLC + Cbra3 
Counter <- as.numeric(c(1:length(Cc)))
RateCr3model <- lm(Crra3 ~ Counter)
RateCr3 <- coef(RateCr3model)[2] * 60 
RateCb3model <- lm(Cbra3 ~ Counter)
RateCb3 <- coef(RateCb3model)[2] * 60 
RateCi3model <- lm(Cira3 ~ Counter)
RateCi3 <- coef(RateCi3model)[2] * 60 
RateCcmodel <- lm(Cc ~ Counter)
RateCc <- coef(RateCcmodel)[2] * 60 

Anet <- c(A, Ara1, Ara2, Ara3)
Aapp <- c(Aapparent, Aapparentra1, Aapparentra2, Aapparentra3)
Ccfull <- rep(Cc, 4)
Cifull <- c(Ci, Cira1, Cira2, Cira3)
Deactivation <-
  c(
    rep("None", length(A)),
    rep("Low", length(Ara1)),
    rep("Medium", length(Ara2)),
    rep("High", length(Ara3))
  )
RASdata <-
  as.data.frame(cbind(Anet, Aapp, Ccfull, Cifull, Deactivation))
write.csv(RASdata, "./data/RASdata.csv")
```

### 酶失活作图 {#Graphs-deac}

```{r, anetdeccc, fig.cap="Rubisco 不同失活程度时 Anet VS Cc", message=FALSE}
data <- read.csv("./data/RASdata.csv")
data$Ccfull <- as.numeric(data$Ccfull)
data$Deactivation <- as.factor(data$Deactivation)

AnetCc <-
  ggplot(data, aes(x = Ccfull, y = Anet, colour = Deactivation)) +
  geom_point() +
  labs(x = expression(C[c] ~ "(" * mu * mol ~ mol ^ {
    -1
  } * ")"),
  y = expression(A[net] ~ "(" * mu * mol ~ m ^ {
    -2
  } ~ s ^ {
    -1
  } * ")")) +
  labs(colour = 'Deactivation') +
  scale_x_continuous(limits = c(25, 100),
                     breaks = c(25, 40, 55, 70, 85, 100)) +
  scale_y_continuous(limits = c(-5, 5)) +
  scale_colour_brewer(palette = 'Spectral') +
  geom_hline(yintercept = 0) +
  theme_bw() +
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank())
AnetCc
```


```{r, anetdecci, fig.cap="Rubisco 不同失活程度时 Anet VS Ci", message=FALSE}
AnetCi <-
  ggplot(data, aes(x = Cifull, y = Anet, colour = Deactivation)) +
  geom_point() +
  labs(x = expression(C[i] ~ "(" * mu * mol ~ mol ^ {
    -1
  } * ")"),
  y = expression(A[net] ~ "(" * mu * mol ~ m ^ {
    -2
  } ~ s ^ {
    -1
  } * ")")) +
  labs(colour = 'Deactivation') +
  scale_x_continuous(limits = c(25, 100),
                     breaks = c(25, 40, 55, 70, 85, 100)) +
  scale_y_continuous(limits = c(-5, 5)) +
  scale_colour_brewer(palette = 'Spectral') +
  geom_hline(yintercept = 0) +
  theme_bw() +
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank())
AnetCi
```


```{r, aappdeccc, fig.cap="Rubisco 不同失活程度时 Aapp VS Cc", message=FALSE}
AappCc <-
  ggplot(data, aes(x = Ccfull, y = Aapp, colour = Deactivation)) +
  geom_point() +
  labs(x = expression(C[c] ~ "(" * mu * mol ~ mol ^ {
    -1
  } * ")"),
  y = expression(A[apparent] ~ "(" * mu * mol ~ m ^ {
    -2
  } ~ s ^ {
    -1
  } * ")")) +
  labs(colour = 'Deactivation') +
  scale_x_continuous(limits = c(25, 75),
                     breaks = c(25, 35, 45, 55, 65, 75)) +
  scale_y_continuous(limits = c(-5, 5)) +
  scale_colour_brewer(palette = 'Spectral') +
  geom_hline(yintercept = 0) +
  theme_bw() +
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank())
AappCc
```


```{r, aappdecci, fig.cap="Rubisco 不同失活程度时 Aapp VS Ci", message=FALSE}
AappCi <-
  ggplot(data, aes(x = Cifull, y = Aapp, colour = Deactivation)) +
  geom_point() +
  labs(x = expression(C[i] ~ "(" * mu * mol ~ mol ^ {
    -1
  } * ")"),
  y = expression(A[apparent] ~ "(" * mu * mol ~ m ^ {
    -2
  } ~ s ^ {
    -1
  } * ")")) +
  labs(colour = 'Deactivation') +
  scale_x_continuous(limits = c(25, 75),
                     breaks = c(25, 35, 45, 55, 65, 75)) +
  scale_y_continuous(limits = c(-5, 5)) +
  scale_colour_brewer(palette = 'Spectral') +
  geom_hline(yintercept = 0) +
  theme_bw() +
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank())
AappCi
```

### 不同失活程度下补偿点计算{#comp-est-dea}

此部分内容同未失活状态相似，不在额外介绍，可参考 \@ref(gammastar) 内容。

```{r}
#Gamma
# For Ci-based estimates, only use Ci < 100
dataCi <- data[data$Cifull < 100, ]
dataCinone <- dataCi[dataCi$Deactivation == "None", ]
dataCilow <- dataCi[dataCi$Deactivation == "Low", ]
dataCimedium <- dataCi[dataCi$Deactivation == "Medium", ]
dataCihigh <- dataCi[dataCi$Deactivation == "High", ]
m1 <- lm(dataCinone$Anet ~ dataCinone$Cifull)
summary(m1)
Gammanone <- -m1$coefficients[1] / m1$coefficients[2]
m2 <- lm(dataCilow$Anet ~ dataCilow$Cifull)
summary(m2)
Gammalow <- -m2$coefficients[1] / m2$coefficients[2]
m3 <- lm(dataCimedium$Anet ~ dataCimedium$Cifull)
summary(m3)
Gammamedium <- -m3$coefficients[1] / m3$coefficients[2]
m4 <- lm(dataCihigh$Anet ~ dataCihigh$Cifull)
summary(m4)
Gammahigh <- -m4$coefficients[1] / m4$coefficients[2]

GammaCi <- c(Gammanone, Gammalow, Gammamedium, Gammahigh)

# For Cc-based estimates, only use Cc < 75
dataCc <- data[data$Ccfull < 75, ]
dataCcnone <- dataCc[dataCc$Deactivation == "None", ]
dataCclow <- dataCc[dataCc$Deactivation == "Low", ]
dataCcmedium <- dataCc[dataCc$Deactivation == "Medium", ]
dataCchigh <- dataCc[dataCc$Deactivation == "High", ]
m1 <- lm(dataCcnone$Anet ~ dataCcnone$Ccfull)
summary(m1)
Gammanone <- -m1$coefficients[1] / m1$coefficients[2]
m2 <- lm(dataCclow$Anet ~ dataCclow$Ccfull)
summary(m2)
Gammalow <- -m2$coefficients[1] / m2$coefficients[2]
m3 <- lm(dataCcmedium$Anet ~ dataCcmedium$Ccfull)
summary(m3)
Gammamedium <- -m3$coefficients[1] / m3$coefficients[2]
m4 <- lm(dataCchigh$Anet ~ dataCchigh$Ccfull)
summary(m4)
Gammahigh <- -m4$coefficients[1] / m4$coefficients[2]

GammaCc <- c(Gammanone, Gammalow, Gammamedium, Gammahigh)

#GammaStar
# For Ci-based estimates, only use Ci < 100
dataCi <- data[data$Cifull < 100, ]
dataCinone <- dataCi[dataCi$Deactivation == "None", ]
dataCilow <- dataCi[dataCi$Deactivation == "Low", ]
dataCimedium <- dataCi[dataCi$Deactivation == "Medium", ]
dataCihigh <- dataCi[dataCi$Deactivation == "High", ]
m1 <- lm(dataCinone$Aapp ~ dataCinone$Cifull)
summary(m1)
Gammastarnone <- -m1$coefficients[1] / m1$coefficients[2]
m2 <- lm(dataCilow$Aapp ~ dataCilow$Cifull)
summary(m2)
Gammastarlow <- -m2$coefficients[1] / m2$coefficients[2]
m3 <- lm(dataCimedium$Aapp ~ dataCimedium$Cifull)
summary(m3)
Gammastarmedium <- -m3$coefficients[1] / m3$coefficients[2]
m4 <- lm(dataCihigh$Aapp ~ dataCihigh$Cifull)
summary(m4)
Gammastarhigh <- -m4$coefficients[1] / m4$coefficients[2]

GammastarCi <-
  c(Gammastarnone, Gammastarlow, Gammastarmedium, Gammastarhigh)

# For Cc-based estimates, only use Cc < 75
dataCc <- data[data$Ccfull < 75, ]
dataCcnone <- dataCc[dataCc$Deactivation == "None", ]
dataCclow <- dataCc[dataCc$Deactivation == "Low", ]
dataCcmedium <- dataCc[dataCc$Deactivation == "Medium", ]
dataCchigh <- dataCc[dataCc$Deactivation == "High", ]
m1 <- lm(dataCcnone$Aapp ~ dataCcnone$Ccfull)
summary(m1)
Gammastarnone <- -m1$coefficients[1] / m1$coefficients[2]
m2 <- lm(dataCclow$Aapp ~ dataCclow$Ccfull)
summary(m2)
Gammastarlow <- -m2$coefficients[1] / m2$coefficients[2]
m3 <- lm(dataCcmedium$Aapp ~ dataCcmedium$Ccfull)
summary(m3)
Gammastarmedium <- -m3$coefficients[1] / m3$coefficients[2]
m4 <- lm(dataCchigh$Aapp ~ dataCchigh$Ccfull)
summary(m4)
Gammastarhigh <- -m4$coefficients[1] / m4$coefficients[2]

GammastarCc <-
  c(Gammastarnone, Gammastarlow, Gammastarmedium, Gammastarhigh)

Deactivation2 <- c("None", "Low", "Medium", "High")
RAScomps <-
  as.data.frame(cbind(Deactivation2, GammaCc, GammaCi, GammastarCc, GammastarCi))
write.csv(RAScomps, "./data/RAScomps.csv")
```


## 时间延迟的扩散限制 {#diffu-limi}

对于扩散限制，下面的内容比较了多速率 RACiR 和标准 ACi 曲线的差别，比较实在有光呼吸和没有光呼吸的两种情况。对于没有扩散限制的表观光合速，采用了已知质量的碱石灰药品，放置于 1.7 ml 的微量离心管内，然后将其置于荧光叶室内部模拟叶片，此时叶室环境控制与其他实验不同，此时不再控制 H2OR。RACiR 测试从 500 到 0 的变化，不同样品的测量是随机的。

下面内容采用了一定的假设，来计算扩散的时间。

```{r}
#Equations from Campbell & Norman, 1998
#We are taking a simple approach to calculating diffusion times.
#Here we make the simplifying assumption that diffusion is pure, planar
#Diffusion, such that:
#gtot = phat * D / deltaZ
#where gtot is total conductance, phat is molar density of air in mol /m^3,
#D is diffusion coefficient in m2/s, deltaZ is pathlength in m
#Since PV = NRT, N/V = P/RT
#T in K, R in J K-1 mol-1, P in Pa

#phat = Patm/(RT)
phat = 100000 / (8.314 * 298.15)

#We also assume a linear pathlength
#Note, if diffusion is nonlinear or nonplanar, it will affect the value determined
#for D from this equation.

#D = gtot * deltaZ / phat

#Diffusion time, t, varies with D and deltaZ such that:

#t = (deltaZ)^2 / D

#So

#t = (deltaZ)^2 / (gtot * deltaZ / phat)

#If we assume mean diffusion pathlength of 1/2 lamina thickness,
#then Onoda et al. 2011 lamina thicknesses of: median 0.22 mm (0.11 to 0.74 for 95% CI)
#becomes 0.11 mm (0.055 to 0.37) for estimated deltaZ

#Convert pathlength to m
dZlow <- 0.055 / 1000
dZmedian <- 0.11 / 1000
dZhigh <- 0.37 / 1000

```

下面的内容是对边界层导度和气孔导度等赋值，由此而计算出其他所需要的参数：
```{r}
#Mesophyll Conductance
BLC <- 2 #mol m-2 s-1
gsw <- 0.4 #mol m-2 s-1

# 无限制的叶肉导度，并以此计算ci等
gm1 <- 1 #mol m-2 s-1
Ci1 <- A / gm1 + Cc #umol mol-1
Cim1 <- Ci1
Cb1 <- A / gsw + Ci1 #umol mol-1
Cr1 <- A / BLC + Cb1 #umol mol-1
#根据斜率计算达到 100 ppm min-1 时记录数据的个数
Counter <- as.numeric(c(1:length(Cc)))
RateCrmodel <- lm(Cr1 ~ Counter)
x1 <- 100 / coef(RateCrmodel)[2] 
RateCr1 <- coef(RateCrmodel)[2] * x1 #umol mol-1 min-1
#计算ci，Cc等达到100ppm min-1 时数据的个数
RateCbmodel <- lm(Cb1 ~ Counter)
RateCb1 <- coef(RateCbmodel)[2] * x1 #umol mol-1 min-1
RateCimodel <- lm(Ci1 ~ Counter)
RateCi1 <- coef(RateCimodel)[2] * x1 #umol mol-1 min-1
RateCcmodel <- lm(Cc ~ Counter)
RateCc1 <- coef(RateCcmodel)[2] * x1 #umol mol-1 min-1
#总的阻力
res1 <- 1 / gm1 + 1 / BLC + 1 / gsw

#不同的叶肉导度计算其他参数
gm2 <- 2 #mol m-2 s-1
Ci2 <- A / gm2 + Cc #umol mol-1
Cim2 <- Ci2
Cb2 <- A / gsw + Ci2 #umol mol-1
Cr2 <- A / BLC + Cb2 #umol mol-1
Counter <- as.numeric(c(1:length(Cc)))
RateCrmodel <- lm(Cr2 ~ Counter)
x2 <- 100 / coef(RateCrmodel)[2] 
RateCr2 <- coef(RateCrmodel)[2] * x2 #umol mol-1 min-1
RateCbmodel <- lm(Cb2 ~ Counter)
RateCb2 <- coef(RateCbmodel)[2] * x2 #umol mol-1 min-1
RateCimodel <- lm(Ci2 ~ Counter)
RateCi2 <- coef(RateCimodel)[2] * x2 #umol mol-1 min-1
RateCcmodel <- lm(Cc ~ Counter)
RateCc2 <- coef(RateCcmodel)[2] * x2 #umol mol-1 min-1
res2 <- 1 / gm2 + 1 / BLC + 1 / gsw

#再次计算不同导度下的数值
gm4 <- 4 #mol m-2 s-1
Ci4 <- A / gm4 + Cc #umol mol-1
Cim4 <- Ci4
Cb4 <- A / gsw + Ci4 #umol mol-1
Cr4 <- A / BLC + Cb4 #umol mol-1
Counter <- as.numeric(c(1:length(Cc)))
RateCrmodel <- lm(Cr4 ~ Counter)
x4 <- 100 / coef(RateCrmodel)[2]
RateCr4 <- coef(RateCrmodel)[2] * x4 #umol mol-1 min-1
RateCbmodel <- lm(Cb4 ~ Counter)
RateCb4 <- coef(RateCbmodel)[2] * x4 #umol mol-1 min-1
RateCimodel <- lm(Ci4 ~ Counter)
RateCi4 <- coef(RateCimodel)[2] * x4 #umol mol-1 min-1
RateCcmodel <- lm(Cc ~ Counter)
RateCc4 <- coef(RateCcmodel)[2] * x4 #umol mol-1 min-1
res4 <- 1 / gm4 + 1 / BLC + 1 / gsw

#再次计算不同导度下的数值
gm05 <- 0.5 #mol m-2 s-1
Ci05 <- A / gm05 + Cc #umol mol-1
Cim05 <- Ci05
Cb05 <- A / gsw + Ci05 #umol mol-1
Cr05 <- A / BLC + Cb05 #umol mol-1
Counter <- as.numeric(c(1:length(Cc)))
RateCrmodel <- lm(Cr05 ~ Counter)
x05 <- 100 / coef(RateCrmodel)[2]
RateCr05 <- coef(RateCrmodel)[2] * x05 #umol mol-1 min-1
RateCbmodel <- lm(Cb05 ~ Counter)
RateCb05 <- coef(RateCbmodel)[2] * x05 #umol mol-1 min-1
RateCimodel <- lm(Ci05 ~ Counter)
RateCi05 <- coef(RateCimodel)[2] * x05 #umol mol-1 min-1
RateCcmodel <- lm(Cc ~ Counter)
RateCc05 <- coef(RateCcmodel)[2] * x05 #umol mol-1 min-1
res05 <- 1 / gm05 + 1 / BLC + 1 / gsw

#正常的叶肉导度数据计算其他参数
gm025 <- 0.25 #mol m-2 s-1
Ci025 <- A / gm025 + Cc #umol mol-1
Cim025 <- Ci025
Cb025 <- A / gsw + Ci025 #umol mol-1
Cr025 <- A / BLC + Cb025 #umol mol-1
Counter <- as.numeric(c(1:length(Cc)))
RateCrmodel <- lm(Cr025 ~ Counter)
x025 <- 100 / coef(RateCrmodel)[2]
RateCr025 <- coef(RateCrmodel)[2] * x025 #umol mol-1 min-1
RateCbmodel <- lm(Cb025 ~ Counter)
RateCb025 <- coef(RateCbmodel)[2] * x025 #umol mol-1 min-1
RateCimodel <- lm(Ci025 ~ Counter)
RateCi025 <- coef(RateCimodel)[2] * x025 #umol mol-1 min-1
RateCcmodel <- lm(Cc ~ Counter)
RateCc025 <- coef(RateCcmodel)[2] * x025 #umol mol-1 min-1
res025 <- 1 / gm025 + 1 / BLC + 1 / gsw

#另一个正常的叶肉导度
gm0125 <- 0.125 #mol m-2 s-1
Ci0125 <- A / gm0125 + Cc #umol mol-1
Cim0125 <- Ci0125
Cb0125 <- A / gsw + Ci0125 #umol mol-1
Cr0125 <- A / BLC + Cb0125 #umol mol-1
Counter <- as.numeric(c(1:length(Cc)))
RateCrmodel <- lm(Cr0125 ~ Counter)
x0125 <- 100 / coef(RateCrmodel)[2]
RateCr0125 <- coef(RateCrmodel)[2] * x0125 #umol mol-1 min-1
RateCbmodel <- lm(Cb0125 ~ Counter)
RateCb0125 <- coef(RateCbmodel)[2] * x0125 #umol mol-1 min-1
RateCimodel <- lm(Ci0125 ~ Counter)
RateCi0125 <- coef(RateCimodel)[2] * x0125 #umol mol-1 min-1
RateCcmodel <- lm(Cc ~ Counter)
RateCc0125 <- coef(RateCcmodel)[2] * x0125 #umol mol-1 min-1
res0125 <- 1 / gm0125 + 1 / BLC + 1 / gsw

#利用不同叶肉导度的数据计算结果构造数据
Ratesgm <-
  c(RateCc0125, RateCc025, RateCc05, RateCc1, RateCc2, RateCc4)
gmval <- c(0.125, 0.25, 0.5, 1, 2, 4)
totalresgm <- c(res0125, res025, res05, res1, res2, res4)
resistance <-
  c(
    rep(res0125, 376),
    rep(res025, 376),
    rep(res05, 376),
    rep(res1, 376),
    rep(res2, 376),
    rep(res4, 376)
  )

#其余部分与上面类似
#此时采用不同的气孔导度构建数据
BLC <- 2 #mol m-2 s-1
gm <- 1 #mol m-2 s-1

gsw <- 0.4 #mol m-2 s-1
Ci1 <- A / gm + Cc #umol mol-1
Cis04 <- Ci1
Cb1 <- A / gsw + Ci1 #umol mol-1
Cr1 <- A / BLC + Cb1 #umol mol-1
Counter <- as.numeric(c(1:length(Cc)))
RateCrmodel <- lm(Cr1 ~ Counter)
x1 <- 100 / coef(RateCrmodel)[2] 
RateCr1 <- coef(RateCrmodel)[2] * x1 #umol mol-1 min-1
RateCbmodel <- lm(Cb1 ~ Counter)
RateCb1 <- coef(RateCbmodel)[2] * x1 #umol mol-1 min-1
RateCimodel <- lm(Ci1 ~ Counter)
RateCi1 <- coef(RateCimodel)[2] * x1 #umol mol-1 min-1
RateCcmodel <- lm(Cc ~ Counter)
RateCc04 <- coef(RateCcmodel)[2] * x1 #umol mol-1 min-1
res04 <- 1 / gm + 1 / BLC + 1 / gsw

gsw <- 0.2 #mol m-2 s-1
Ci1 <- A / gm + Cc #umol mol-1
Cis02 <- Ci1
Cb1 <- A / gsw + Ci1 #umol mol-1
Cr1 <- A / BLC + Cb1 #umol mol-1
Counter <- as.numeric(c(1:length(Cc)))
RateCrmodel <- lm(Cr1 ~ Counter)
x1 <- 100 / coef(RateCrmodel)[2]
RateCr1 <- coef(RateCrmodel)[2] * x1 #umol mol-1 min-1
RateCbmodel <- lm(Cb1 ~ Counter)
RateCb1 <- coef(RateCbmodel)[2] * x1 #umol mol-1 min-1
RateCimodel <- lm(Ci1 ~ Counter)
RateCi1 <- coef(RateCimodel)[2] * x1 #umol mol-1 min-1
RateCcmodel <- lm(Cc ~ Counter)
RateCc02 <- coef(RateCcmodel)[2] * x1 #umol mol-1 min-1
res02 <- 1 / gm + 1 / BLC + 1 / gsw

gsw <- 0.1 #mol m-2 s-1
Ci1 <- A / gm + Cc #umol mol-1
Cis01 <- Ci1
Cb1 <- A / gsw + Ci1 #umol mol-1
Cr1 <- A / BLC + Cb1 #umol mol-1
Counter <- as.numeric(c(1:length(Cc)))
RateCrmodel <- lm(Cr1 ~ Counter)
x1 <- 100 / coef(RateCrmodel)[2]
RateCr1 <- coef(RateCrmodel)[2] * x1 #umol mol-1 min-1
RateCbmodel <- lm(Cb1 ~ Counter)
RateCb1 <- coef(RateCbmodel)[2] * x1 #umol mol-1 min-1
RateCimodel <- lm(Ci1 ~ Counter)
RateCi1 <- coef(RateCimodel)[2] * x1 #umol mol-1 min-1
RateCcmodel <- lm(Cc ~ Counter)
RateCc01 <- coef(RateCcmodel)[2] * x1 #umol mol-1 min-1
res01 <- 1 / gm + 1 / BLC + 1 / gsw

gsw <- 0.05 #mol m-2 s-1
Ci1 <- A / gm + Cc #umol mol-1
Cis05 <- Ci1
Cb1 <- A / gsw + Ci1 #umol mol-1
Cr1 <- A / BLC + Cb1 #umol mol-1
Counter <- as.numeric(c(1:length(Cc)))
RateCrmodel <- lm(Cr1 ~ Counter)
x1 <- 100 / coef(RateCrmodel)[2]
RateCr1 <- coef(RateCrmodel)[2] * x1 #umol mol-1 min-1
RateCbmodel <- lm(Cb1 ~ Counter)
RateCb1 <- coef(RateCbmodel)[2] * x1 #umol mol-1 min-1
RateCimodel <- lm(Ci1 ~ Counter)
RateCi1 <- coef(RateCimodel)[2] * x1 #umol mol-1 min-1
RateCcmodel <- lm(Cc ~ Counter)
RateCc005 <- coef(RateCcmodel)[2] * x1 #umol mol-1 min-1
res005 <- 1 / gm + 1 / BLC + 1 / gsw

gsw <- 0.025 #mol m-2 s-1
Ci1 <- A / gm + Cc #umol mol-1
Cis0025 <- Ci1
Cb1 <- A / gsw + Ci1 #umol mol-1
Cr1 <- A / BLC + Cb1 #umol mol-1
Counter <- as.numeric(c(1:length(Cc)))
RateCrmodel <- lm(Cr1 ~ Counter)
x1 <- 100 / coef(RateCrmodel)[2]
RateCr1 <- coef(RateCrmodel)[2] * x1 #umol mol-1 min-1
RateCbmodel <- lm(Cb1 ~ Counter)
RateCb1 <- coef(RateCbmodel)[2] * x1 #umol mol-1 min-1
RateCimodel <- lm(Ci1 ~ Counter)
RateCi1 <- coef(RateCimodel)[2] * x1 #umol mol-1 min-1
RateCcmodel <- lm(Cc ~ Counter)
RateCc0025 <- coef(RateCcmodel)[2] * x1 #umol mol-1 min-1
res0025 <- 1 / gm + 1 / BLC + 1 / gsw

Ratesgsw <- c(RateCc0025, RateCc005, RateCc01, RateCc02, RateCc04)
gswvals <- c(0.025, 0.05, 0.1, 0.2, 0.4)
totalresgsw <- c(res0025, res005, res01, res02, res04)

# 下面的代码是采用不同的边界层导度
# 含义与上面代码相似
gm <- 1 #mol m-2 s-1
gsw <- 0.4 #mol m-2 s-1

BLC <- 2 #mol m-2 s-1

Ci1 <- A / gm + Cc #umol mol-1
Cib2 <- Ci1
Cb1 <- A / gsw + Ci1 #umol mol-1
Cr1 <- A / BLC + Cb1 #umol mol-1
Counter <- as.numeric(c(1:length(Cc)))
RateCrmodel <- lm(Cr1 ~ Counter)
x1 <- 100 / coef(RateCrmodel)[2]
RateCr1 <- coef(RateCrmodel)[2] * x1 #umol mol-1 min-1
RateCbmodel <- lm(Cb1 ~ Counter)
RateCb1 <- coef(RateCbmodel)[2] * x1 #umol mol-1 min-1
RateCimodel <- lm(Ci1 ~ Counter)
RateCi1 <- coef(RateCimodel)[2] * x1 #umol mol-1 min-1
RateCcmodel <- lm(Cc ~ Counter)
RateCc2 <- coef(RateCcmodel)[2] * x1 #umol mol-1 min-1
res2 <- 1 / gm + 1 / BLC + 1 / gsw

BLC <- 4 #mol m-2 s-1

Ci1 <- A / gm + Cc #umol mol-1
Cib4 <- Ci1
Cb1 <- A / gsw + Ci1 #umol mol-1
Cr1 <- A / BLC + Cb1 #umol mol-1
Counter <- as.numeric(c(1:length(Cc)))
RateCrmodel <- lm(Cr1 ~ Counter)
x1 <- 100 / coef(RateCrmodel)[2]
RateCr1 <- coef(RateCrmodel)[2] * x1 #umol mol-1 min-1
RateCbmodel <- lm(Cb1 ~ Counter)
RateCb1 <- coef(RateCbmodel)[2] * x1 #umol mol-1 min-1
RateCimodel <- lm(Ci1 ~ Counter)
RateCi1 <- coef(RateCimodel)[2] * x1 #umol mol-1 min-1
RateCcmodel <- lm(Cc ~ Counter)
RateCc4 <- coef(RateCcmodel)[2] * x1 #umol mol-1 min-1
res4 <- 1 / gm + 1 / BLC + 1 / gsw

BLC <- 1 #mol m-2 s-1

Ci1 <- A / gm + Cc #umol mol-1
Cib1 <- Ci1
Cb1 <- A / gsw + Ci1 #umol mol-1
Cr1 <- A / BLC + Cb1 #umol mol-1
Counter <- as.numeric(c(1:length(Cc)))
RateCrmodel <- lm(Cr1 ~ Counter)
x1 <- 100 / coef(RateCrmodel)[2]
RateCr1 <- coef(RateCrmodel)[2] * x1 #umol mol-1 min-1
RateCbmodel <- lm(Cb1 ~ Counter)
RateCb1 <- coef(RateCbmodel)[2] * x1 #umol mol-1 min-1
RateCimodel <- lm(Ci1 ~ Counter)
RateCi1 <- coef(RateCimodel)[2] * x1 #umol mol-1 min-1
RateCcmodel <- lm(Cc ~ Counter)
RateCc1 <- coef(RateCcmodel)[2] * x1 #umol mol-1 min-1
res1 <- 1 / gm + 1 / BLC + 1 / gsw

BLC <- 0.5 #mol m-2 s-1

Ci1 <- A / gm + Cc #umol mol-1
Cb1 <- A / gsw + Ci1 #umol mol-1
Cib05 <- Ci1
Cr1 <- A / BLC + Cb1 #umol mol-1
Counter <- as.numeric(c(1:length(Cc)))
RateCrmodel <- lm(Cr1 ~ Counter)
x1 <- 100 / coef(RateCrmodel)[2]
RateCr1 <- coef(RateCrmodel)[2] * x1 #umol mol-1 min-1
RateCbmodel <- lm(Cb1 ~ Counter)
RateCb1 <- coef(RateCbmodel)[2] * x1 #umol mol-1 min-1
RateCimodel <- lm(Ci1 ~ Counter)
RateCi1 <- coef(RateCimodel)[2] * x1 #umol mol-1 min-1
RateCcmodel <- lm(Cc ~ Counter)
RateCc05 <- coef(RateCcmodel)[2] * x1 #umol mol-1 min-1
res05 <- 1 / gm + 1 / BLC + 1 / gsw

BLC <- 0.25 #mol m-2 s-1

Ci1 <- A / gm + Cc #umol mol-1
Cb1 <- A / gsw + Ci1 #umol mol-1
Cib025 <- Ci1
Cr1 <- A / BLC + Cb1 #umol mol-1
Counter <- as.numeric(c(1:length(Cc)))
RateCrmodel <- lm(Cr1 ~ Counter)
x1 <- 100 / coef(RateCrmodel)[2]
RateCr1 <- coef(RateCrmodel)[2] * x1 #umol mol-1 min-1
RateCbmodel <- lm(Cb1 ~ Counter)
RateCb1 <- coef(RateCbmodel)[2] * x1 #umol mol-1 min-1
RateCimodel <- lm(Ci1 ~ Counter)
RateCi1 <- coef(RateCimodel)[2] * x1 #umol mol-1 min-1
RateCcmodel <- lm(Cc ~ Counter)
RateCc025 <- coef(RateCcmodel)[2] * x1 #umol mol-1 min-1
res025 <- 1 / gm + 1 / BLC + 1 / gsw

BLCRates <- c(RateCc025, RateCc05, RateCc1, RateCc2, RateCc4)
BLCvals <- c(0.25, 0.5, 1, 2, 4)
totalresBLC <- c(res025, res05, res1, res2, res4)

Scenario <-
  c(
    rep("Boundary Layer Conductance", 5),
    rep("Stomatal Conductance", 5),
    rep("Mesophyll Conductance", 6)
  )
Rates <- c(BLCRates, Ratesgsw, Ratesgm)
Conductances <- c(BLCvals, gswvals, gmval)
TotalRes <- c(totalresBLC, totalresgsw, totalresgm)

Cidiffusion <- c(Cim0125, Cim025, Cim05, Cim1, Cim2, Cim4)
Adiffusion <- rep(A, 6)
Aappdiffusion <- rep(Aapparent, 6)
variable <- c(rep("Mesophyll Conductance", 6 * length(Cim1)))
conductance <-
  c(rep(0.125, 376),
    rep(0.25, 376),
    rep(0.5, 376),
    rep(1, 376),
    rep(2, 376),
    rep(4, 376))


Diffusionplot <-
  as.data.frame(cbind(
    Cidiffusion,
    Adiffusion,
    Aappdiffusion,
    variable,
    conductance,
    resistance
  ))
write.csv(Diffusionplot, "./data/DiffusionLimitsACI.csv")

Diffusion <-
  as.data.frame(cbind(Scenario, Rates, Conductances, TotalRes))
write.csv(Diffusion, "./data/DiffusionLimits.csv")
```

```{r}
knitr::kable(head(Diffusion))
```


### 扩散限制滞后性 {#difu-limit}

下面的代码，是根据上面代码的计算结果，结合最初的扩散时间的公式，来计算出各个参数的最大最小值，中间值，构造数据：

```{r}
gtot1 <- 1 / res1
t1low = (dZlow) ^ 2 / (gtot1 * dZlow / phat)
t1median = (dZmedian) ^ 2 / (gtot1 * dZmedian / phat)
t1high = (dZhigh) ^ 2 / (gtot1 * dZhigh / phat)
Cc1low <- c(Cc + (t1low * RateCc1))
Cc1median <- c(Cc + (t1median * RateCc1))
Cc1high <- c(Cc + (t1high * RateCc1))
vo1low <- Vomax * O2 / (O2 + Ko * (1 + Cc1low / Kc)) 
A1low <- vc - 0.5 * vo1low - R 
vo1median <- Vomax * O2 / (O2 + Ko * (1 + Cc1median / Kc)) 
A1median <- vc - 0.5 * vo1median - R 
vo1high <- Vomax * O2 / (O2 + Ko * (1 + Cc1high / Kc)) 
A1high <- vc - 0.5 * vo1high - R 

gtot0125 <- 1 / res0125
t0125low = (dZlow) ^ 2 / (gtot0125 * dZlow / phat)
t0125median = (dZmedian) ^ 2 / (gtot0125 * dZmedian / phat)
t0125high = (dZhigh) ^ 2 / (gtot0125 * dZhigh / phat)
Cc0125low <- c(Cc + (t0125low * RateCc0125))
Cc0125median <- c(Cc + (t0125median * RateCc0125))
Cc0125high <- c(Cc + (t0125high * RateCc0125))
vo0125low <- Vomax * O2 / (O2 + Ko * (1 + Cc0125low / Kc)) 
A0125low <- vc - 0.5 * vo0125low - R 
vo0125median <- Vomax * O2 / (O2 + Ko * (1 + Cc0125median / Kc)) 
A0125median <- vc - 0.5 * vo0125median - R 
vo0125high <- Vomax * O2 / (O2 + Ko * (1 + Cc0125high / Kc)) 
A0125high <- vc - 0.5 * vo0125high - R 

gtot025 <- 1 / res025
t025low = (dZlow) ^ 2 / (gtot025 * dZlow / phat)
t025median = (dZmedian) ^ 2 / (gtot025 * dZmedian / phat)
t025high = (dZhigh) ^ 2 / (gtot025 * dZhigh / phat)
Cc025low <- c(Cc + (t025low * RateCc025))
Cc025median <- c(Cc + (t025median * RateCc025))
Cc025high <- c(Cc + (t025high * RateCc025))
vo025low <- Vomax * O2 / (O2 + Ko * (1 + Cc025low / Kc)) 
A025low <- vc - 0.5 * vo025low - R 
vo025median <- Vomax * O2 / (O2 + Ko * (1 + Cc025median / Kc)) 
A025median <- vc - 0.5 * vo025median - R 
vo025high <- Vomax * O2 / (O2 + Ko * (1 + Cc025high / Kc)) 
A025high <- vc - 0.5 * vo025high - R 

gtot05 <- 1 / res05
t05low = (dZlow) ^ 2 / (gtot05 * dZlow / phat)
t05median = (dZmedian) ^ 2 / (gtot05 * dZmedian / phat)
t05high = (dZhigh) ^ 2 / (gtot05 * dZhigh / phat)
Cc05low <- c(Cc + (t05low * RateCc05))
Cc05median <- c(Cc + (t05median * RateCc05))
Cc05high <- c(Cc + (t05high * RateCc05))
vo05low <- Vomax * O2 / (O2 + Ko * (1 + Cc05low / Kc)) 
A05low <- vc - 0.5 * vo05low - R 
vo05median <- Vomax * O2 / (O2 + Ko * (1 + Cc05median / Kc)) 
A05median <- vc - 0.5 * vo05median - R 
vo05high <- Vomax * O2 / (O2 + Ko * (1 + Cc05high / Kc)) 
A05high <- vc - 0.5 * vo05high - R 

gtot2 <- 1 / res2
t2low = (dZlow) ^ 2 / (gtot2 * dZlow / phat)
t2median = (dZmedian) ^ 2 / (gtot2 * dZmedian / phat)
t2high = (dZhigh) ^ 2 / (gtot2 * dZhigh / phat)
Cc2low <- c(Cc + (t2low * RateCc2))
Cc2median <- c(Cc + (t2median * RateCc2))
Cc2high <- c(Cc + (t2high * RateCc2))
vo2low <- Vomax * O2 / (O2 + Ko * (1 + Cc2low / Kc)) 
A2low <- vc - 0.5 * vo2low - R 
vo2median <- Vomax * O2 / (O2 + Ko * (1 + Cc2median / Kc)) 
A2median <- vc - 0.5 * vo2median - R 
vo2high <- Vomax * O2 / (O2 + Ko * (1 + Cc2high / Kc)) 
A2high <- vc - 0.5 * vo2high - R 

gtot4 <- 1 / res4
t4low = (dZlow) ^ 2 / (gtot4 * dZlow / phat)
t4median = (dZmedian) ^ 2 / (gtot4 * dZmedian / phat)
t4high = (dZhigh) ^ 2 / (gtot4 * dZhigh / phat)
Cc4low <- c(Cc + (t4low * RateCc4))
Cc4median <- c(Cc + (t4median * RateCc4))
Cc4high <- c(Cc + (t4high * RateCc4))
vo4low <- Vomax * O2 / (O2 + Ko * (1 + Cc4low / Kc)) 
A4low <- vc - 0.5 * vo4low - R 
vo4median <- Vomax * O2 / (O2 + Ko * (1 + Cc4median / Kc)) 
A4median <- vc - 0.5 * vo4median - R 
vo4high <- Vomax * O2 / (O2 + Ko * (1 + Cc4high / Kc)) 
A4high <- vc - 0.5 * vo4high - R 

Cc0125high2 <- c(Cc + (t0125high * RateCc0125 * 2))
Cc025high2 <- c(Cc + (t025high * RateCc025 * 2))
Cc05high2 <- c(Cc + (t05high * RateCc05 * 2))
Cc1high2 <- c(Cc + (t1high * RateCc1 * 2))
Cc2high2 <- c(Cc + (t2high * RateCc2 * 2))
Cc4high2 <- c(Cc + (t4high * RateCc4 * 2))

vo0125high2 <- Vomax * O2 / (O2 + Ko * (1 + Cc0125high2 / Kc)) 
A0125high2 <- vc - 0.5 * vo0125high2 - R 
vo025high2 <- Vomax * O2 / (O2 + Ko * (1 + Cc025high2 / Kc)) 
A025high2 <- vc - 0.5 * vo025high2 - R 
vo05high2 <- Vomax * O2 / (O2 + Ko * (1 + Cc05high2 / Kc)) 
A05high2 <- vc - 0.5 * vo05high2 - R 
vo1high2 <- Vomax * O2 / (O2 + Ko * (1 + Cc1high2 / Kc)) 
A1high2 <- vc - 0.5 * vo1high2 - R 
vo2high2 <- Vomax * O2 / (O2 + Ko * (1 + Cc2high2 / Kc)) 
A2high2 <- vc - 0.5 * vo2high2 - R 
vo4high2 <- Vomax * O2 / (O2 + Ko * (1 + Cc4high2 / Kc)) 
A4high2 <- vc - 0.5 * vo4high2 - R 

Ahigh2 <-
  c(A0125high2, A025high2, A05high2, A1high2, A2high2, A4high2)

Cc0125high3 <- c(Cc + (t0125high * RateCc0125 * 3))
Cc025high3 <- c(Cc + (t025high * RateCc025 * 3))
Cc05high3 <- c(Cc + (t05high * RateCc05 * 3))
Cc1high3 <- c(Cc + (t1high * RateCc1 * 3))
Cc2high3 <- c(Cc + (t2high * RateCc2 * 3))
Cc4high3 <- c(Cc + (t4high * RateCc4 * 3))

vo0125high3 <- Vomax * O2 / (O2 + Ko * (1 + Cc0125high3 / Kc)) 
A0125high3 <- vc - 0.5 * vo0125high3 - R 
vo025high3 <- Vomax * O2 / (O2 + Ko * (1 + Cc025high3 / Kc)) 
A025high3 <- vc - 0.5 * vo025high3 - R 
vo05high3 <- Vomax * O2 / (O2 + Ko * (1 + Cc05high3 / Kc)) 
A05high3 <- vc - 0.5 * vo05high3 - R 
vo1high3 <- Vomax * O2 / (O2 + Ko * (1 + Cc1high3 / Kc)) 
A1high3 <- vc - 0.5 * vo1high3 - R 
vo2high3 <- Vomax * O2 / (O2 + Ko * (1 + Cc2high3 / Kc)) 
A2high3 <- vc - 0.5 * vo2high3 - R 
vo4high3 <- Vomax * O2 / (O2 + Ko * (1 + Cc4high3 / Kc)) 
A4high3 <- vc - 0.5 * vo4high3 - R 

Ahigh3 <-
  c(A0125high3, A025high3, A05high3, A1high3, A2high3, A4high3)

Cidiffusion <- c(Cim0125, Cim025, Cim05, Cim1, Cim2, Cim4)
Alow <- c(A0125low, A025low, A05low, A1low, A2low, A4low)
Amedian <-
  c(A0125median,
    A025median,
    A05median,
    A1median,
    A2median,
    A4median)
Ahigh <- c(A0125high, A025high, A05high, A1high, A2high, A4high)

variable <- c(rep("Mesophyll Conductance", 6 * length(Cim1)))
conductance <-
  c(rep(0.125, 376),
    rep(0.25, 376),
    rep(0.5, 376),
    rep(1, 376),
    rep(2, 376),
    rep(4, 376))

Diffusionplot2 <-
  as.data.frame(
    cbind(
      Cidiffusion,
      Alow,
      Amedian,
      Ahigh,
      Ahigh2,
      Ahigh3,
      variable,
      conductance,
      resistance
    )
  )
write.csv(Diffusionplot2, "./data/DiffusionLimitsACI2.csv")
```

最终够到的不同导度下的扩散数据如下：

```{r}
knitr::kable(head(Diffusionplot2))
```


## 扩散限制作图 {#difu-graph}

```{r,difuci, fig.cap="不同 Ci 扩散限制下的差异", message=FALSE}
data <- read.csv("./data/DiffusionLimitsACI2.csv")
data$resistance <- as.factor(data$resistance)
graph <- ggplot(data, aes(x = Cidiffusion, y = Ahigh3, colour = resistance)) +
  geom_abline(slope=0,intercept=0,size=1.5)+
  geom_point()+
  labs(colour = 'Total Resistance')+
  scale_colour_brewer(palette = 'Spectral') +
  theme_bw() +
  scale_x_continuous(limits=c(0,100))+
  scale_y_continuous(limits=c(-5,10))+
  theme(
    axis.title = element_text(size = 18),
    axis.text = element_text(size = 15),
    legend.position = 'right',
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank()
  )
graph
```


```{r, difuci11, fig.cap="不同 Ci 扩散限制下的差异（resistance = 11）", message=FALSE}
datahigh <- data[data$resistance == "11",]
graph <- ggplot(datahigh, aes(x = Cidiffusion, y = Ahigh3)) +
  geom_abline(slope=0,intercept=0,size=1.5)+
  geom_point(colour = "red")+
  geom_point(aes(x = Cidiffusion, y = Ahigh2), colour = "blue")+
  geom_point(aes(x = Cidiffusion, y = Ahigh), colour = "green")+
  labs(colour = 'Total Resistance')+
  scale_colour_brewer(palette = 'Spectral') +
  theme_bw() +
  scale_x_continuous(limits=c(0,100))+
  scale_y_continuous(limits=c(-2.5,2.5))+
  theme(
    axis.title = element_text(size = 18),
    axis.text = element_text(size = 15),
    legend.position = 'right',
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank()
  )
graph
```


```{r, tolresis, fig.cap="不同总导度下的各个导度的速率变化", message=FALSE}
data2 <- read.csv("./data/DiffusionLimits.csv")
graph <- ggplot(data2, aes(x = TotalRes, y = Rates, colour = Scenario)) +
  geom_point()+
  scale_colour_brewer(palette = 'Spectral') +
  theme_bw() +
  theme(
    axis.title = element_text(size = 18),
    axis.text = element_text(size = 12),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank()
  )
graph
```


```{r, tolre, fig.cap="不同阻力下的各个导度的速率变化预测值", message=FALSE}
m1 <- lm(Rates ~ I(1/TotalRes)+I((1/TotalRes)^2),data=data2)
summary(m1)
ab <- predict(m1)
red <- 1/data2$TotalRes
plot(ab~red)
```

### 补偿点的计算 {#compen-estimate}

计算补偿点，代码同前文类似，只是采用了不同导度下的数值：

```{r}
data <- read.csv("./data/DiffusionLimitsACI2.csv")
#Gamma
# For Ci-based estimates, only use Ci < 100
dataCi <- data[data$Cidiffusion < 100, ]
dataCi0125 <- dataCi[dataCi$conductance == "0.125", ]
dataCi025 <- dataCi[dataCi$conductance == "0.25", ]
dataCi05 <- dataCi[dataCi$conductance == "0.5", ]
dataCi1 <- dataCi[dataCi$conductance == "1", ]
dataCi2 <- dataCi[dataCi$conductance == "2", ]
dataCi4 <- dataCi[dataCi$conductance == "4", ]
m1 <- lm(dataCi0125$Ahigh ~ dataCi0125$Cidiffusion)
summary(m1)
Gamma0125 <- -m1$coefficients[1] / m1$coefficients[2]
m2 <- lm(dataCi025$Ahigh ~ dataCi025$Cidiffusion)
summary(m2)
Gamma025 <- -m2$coefficients[1] / m2$coefficients[2]
m3 <- lm(dataCi05$Ahigh ~ dataCi05$Cidiffusion)
summary(m3)
Gamma05 <- -m3$coefficients[1] / m3$coefficients[2]
m4 <- lm(dataCi1$Ahigh ~ dataCi1$Cidiffusion)
summary(m4)
Gamma1 <- -m4$coefficients[1] / m4$coefficients[2]
m5 <- lm(dataCi2$Ahigh ~ dataCi2$Cidiffusion)
summary(m5)
Gamma2 <- -m5$coefficients[1] / m5$coefficients[2]
m6 <- lm(dataCi4$Ahigh ~ dataCi4$Cidiffusion)
summary(m6)
Gamma4 <- -m6$coefficients[1] / m6$coefficients[2]

GammaCi <- c(Gamma0125, Gamma025, Gamma05, Gamma1, Gamma2, Gamma4)
```

### 所有图形代码 {#all-fig}


```{r, prdataplot, fig.cap="不同时间滞后性的 Anet VS Ci", message=FALSE}
data <- read.csv("./data/PRdata.csv")
data$Ccfull <- as.numeric(data$Ccfull)
data$Delay <- as.factor(data$Delay)
cols <- gg_color_hue(6)
Panel_1A <-
  ggplot(data, aes(
    x = Cifull,
    y = Anet,
    colour = Delay,
    linetype = Delay
  )) +
  # 零水平参考线
  geom_abline(slope = 0,
              intercept = 0,
              size = 1.5) +
  #ci与A loess 方法的拟合曲线
  geom_smooth(method = "loess", se = FALSE, size = 2) +
  scale_linetype_manual(
    name = "Delay (s)",
    labels = c("0", "15", "30", "60", "120", "300"),
    values = c("solid", "longdash", "twodash", "dotdash", "dashed", "dotted")
  ) +
  ggtitle(expression(paste(
    bold("(a)"), " Modelled Photorespiratory Effect"
  ))) +
  labs(x = expression(C[i] ~ "(" * mu * mol ~ mol ^ {
    -1
  } * ")"),
  y = expression(A[net] ~ "(" * mu * mol ~ m ^ {
    -2
  } ~ s ^ {
    -1
  } * ")")) +
  labs(colour = 'Delay (s)') +
  scale_x_continuous(limits = c(0, 250)) +
  scale_y_continuous(limits = c(-5, 20)) +
  scale_colour_manual(
    values = cols,
    name = "Delay (s)",
    labels = c("0", "15", "30", "60", "120", "300")
  ) +
  theme_bw() +
  theme(
    axis.title.x = element_text(size = 20),
    axis.title.y = element_text(size = 20),
    axis.line = element_line(size = 1),
    axis.ticks = element_line(size = 1.5),
    axis.ticks.length = unit(1.5, "mm"),
    rect = element_rect(size = 2),
    axis.text.x = element_text(size = 14, color = 'black'),
    axis.text.y =
      element_text(
        size = 14,
        color = 'black',
        hjust = (1)
      ),
    legend.position = c(0.15, 0.75),
    axis.title = element_text(size = 18),
    axis.text = element_text(size = 12, color = "black"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    legend.text = element_text(size = 14),
    legend.title = element_text(size = 14)
  )
Panel_1A
```


```{r, resistplot, fig.cap="不同总阻力下的 Anet VS Ci", message=FALSE}
Panel_1A_inset <-
  ggplot(data, aes(
    x = Cifull,
    y = Anet,
    colour = Delay,
    linetype = Delay
  )) +
  geom_abline(slope = 0,
              intercept = 0,
              size = 1.5) +
  geom_smooth(method = "loess", se = FALSE, size = 2) +
  scale_linetype_manual(
    name = "Delay (s)",
    labels = c("0", "15", "30", "60", "120", "300"),
    values = c("solid", "longdash", "twodash", "dotdash", "dashed", "dotted")
  ) +
  labs(x = expression(C[i] ~ "(" * mu * mol ~ mol ^ {
    -1
  } * ")"),
  y = expression(A[net] ~ "(" * mu * mol ~ m ^ {
    -2
  } ~ s ^ {
    -1
  } * ")")) +
  labs(colour = 'Delay (s)') +
  scale_x_continuous(limits = c(45, 65)) +
  scale_y_continuous(limits = c(-1, 1), breaks = c(-1, 0, 1)) +
  scale_colour_manual(values = cols) +
  theme_bw() +
  theme(
    axis.title.x = element_blank(),
    axis.title.y = element_blank(),
    axis.line = element_line(size = 1),
    axis.ticks = element_line(size = 1.5),
    axis.ticks.length = unit(1.5, "mm"),
    rect = element_rect(size = 2),
    axis.text.x = element_text(size = 14, color = 'black'),
    axis.text.y =
      element_text(
        size = 14,
        color = 'black',
        hjust = (1)
      ),
    axis.title = element_blank(),
    axis.text = element_text(size = 12, color = "black"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    legend.position = 'none',
    plot.background = element_blank()
  )



cols <- gg_color_hue(6)

data <- read.csv("./data/DiffusionLimitsACI2.csv")
data$resistance <- as.factor(data$resistance)
Panel_1Db <-
  ggplot(data,
         aes(
           x = Cidiffusion,
           y = Ahigh,
           colour = resistance,
           linetype = resistance
         )) +
  geom_abline(slope = 0,
              intercept = 0,
              size = 1.5) +
  geom_smooth(method = "loess", se = FALSE, size = 2) +
  scale_linetype_manual(
    name = "Total Resistance",
    labels = c("3.25", "3.5", "4", "5", "7", "11"),
    values = c("solid", "longdash", "twodash", "dotdash", "dashed", "dotted")
  ) +
  ggtitle(expression(paste(bold("(d)"), " Modelled Resistance Effect"))) +
  scale_color_manual(
    values = cols,
    name = "Total Resistance",
    labels = c("3.25", "3.5", "4", "5", "7", "11")
  ) +
  theme_bw() +
  labs(x = expression(paste(C[i] ~ "(" * mu * mol ~ mol ^ {
    -1
  } * ")")), y = expression(paste(A[net] ~ "(" * mu * mol ~ m ^ {
    -2
  } ~ s ^ {
    -1
  } * ")"))) +
  scale_x_continuous(limits = c(0, 250)) +
  scale_y_continuous(limits = c(-5, 20)) +
  theme(
    axis.title.x = element_text(size = 20),
    axis.title.y = element_text(size = 20),
    axis.line = element_line(size = 1),
    axis.ticks = element_line(size = 1.5),
    axis.ticks.length = unit(1.5, "mm"),
    rect = element_rect(size = 2),
    axis.text.x = element_text(size = 14, color = 'black'),
    axis.text.y =
      element_text(
        size = 14,
        color = 'black',
        hjust = (1)
      ),
    legend.position = c(0.22, 0.75),
    axis.title = element_text(size = 18),
    axis.text = element_text(size = 12, color = "black"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    legend.text = element_text(size = 14),
    legend.title = element_text(size = 14)
  )
Panel_1Db
```


```{r, high3tplot, fig.cap="不同导度下的 A VS Ci", message=FALSE}
data <- read.csv("./data/DiffusionLimitsACI2.csv")
data$resistance <- as.factor(data$resistance)
data <- data[data$resistance == "11",]
resistance <- rep(data$resistance, 3)
Cidiffusion <- rep(data$Cidffusion, 3)
A <- c(data$Ahigh, data$Ahigh2, data$Ahigh3)
Rate <-
  c(rep(100, length(data$Ahigh)), rep(200, length(data$Ahigh2)), rep(300, length(data$Ahigh3)))
data3 <- rbind(data, data, data)
data3$A <- c(data$Ahigh, data$Ahigh2, data$Ahigh3)
data3$Rate <-
  as.factor(c(rep(100, length(data$Ahigh)), rep(200, length(data$Ahigh2)), rep(300, length(data$Ahigh3))))
Panel_1Dbinset <-
  ggplot(data3, aes(
    x = Cidiffusion,
    y = A,
    colour = Rate,
    linetype = Rate
  )) +
  geom_abline(slope = 0,
              intercept = 0,
              size = 1.5) +
  geom_smooth(method = "loess", se = FALSE, size = 2) +
  scale_linetype_manual(
    name = "Rate",
    labels = c("100", "200", "300"),
    values = c("solid", "longdash", "twodash")
  ) +
  scale_color_manual(
    values = cols,
    name = "Rate",
    labels = c("100", "200", "300")
  ) +
  theme_bw() +
  labs(x = expression(paste(C[i] ~ "(" * mu * mol ~ mol ^ {
    -1
  } * ")")), y = expression(paste(A[net] ~ "(" * mu * mol ~ m ^ {
    -2
  } ~ s ^ {
    -1
  } * ")"))) +
  scale_x_continuous(limits = c(45, 65)) +
  scale_y_continuous(limits = c(-1, 1), breaks = c(-1, 0, 1)) +
  theme(
    axis.title.x = element_blank(),
    axis.title.y = element_blank(),
    axis.line = element_line(size = 1),
    axis.ticks = element_line(size = 1.5),
    axis.ticks.length = unit(1.5, "mm"),
    rect = element_rect(size = 2),
    axis.text.x = element_text(size = 14, color = 'black'),
    axis.text.y =
      element_text(
        size = 14,
        color = 'black',
        hjust = (1)
      ),
    legend.position = c(0.22, 0.75),
    axis.title = element_text(size = 18),
    axis.text = element_text(size = 12, color = "black"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    plot.background = element_blank(),
    legend.text = element_text(size = 12),
    legend.key = element_blank(),
    legend.title = element_blank(),
    legend.background = element_blank()
  )
Panel_1Dbinset
```


```{r, toresratetplot, fig.cap="不同总导度下的各个导度的变化", message=FALSE}
data2 <- read.csv("./data/DiffusionLimits.csv")
data2$Conductance <-
  revalue(
    data2$Scenario,
    c(
      "Boundary Layer Conductance" = "Boundary Layer",
      "Mesophyll Conductance" = "Mesophyll",
      "Stomatal Conductance" = "Stomatal"
    )
  )
cols <- gg_color_hue(3)

Panel_1E <-
  ggplot(data2, aes(x = TotalRes, y = Rates, colour = Conductance)) +
  geom_point(size = 4) +
  ggtitle(expression(paste(bold("(e)"), " Modelled Resistance Effect"))) +
  labs(x = expression(paste(r[total] * " (s" ~ m ^ {
    2
  } ~ mol ^ {
    -1
  } * ")")), 
  y = expression(paste(C[c] * " Ramp Rate (" * mu * mol ~ mol ^
                                    {
                                      -1
                                    } ~ min ^ {
                                      -1
                                    } * ")"))) +
  scale_x_continuous(limits = c(0, 50)) +
  scale_y_continuous(limits = c(0, 80)) +
  scale_color_manual(
    values = cols,
    name = "Manipulated Resistance",
    labels = c("Boundary Layer", "Mesophyll", "Stomatal")
  ) +
  theme_bw() +
  theme(
    axis.title.x = element_text(size = 20),
    axis.title.y = element_text(size = 20),
    axis.line = element_line(size = 1),
    axis.ticks = element_line(size = 1.5),
    axis.ticks.length = unit(1.5, "mm"),
    rect = element_rect(size = 2),
    axis.text.x = element_text(size = 14, color = 'black'),
    axis.text.y =
      element_text(
        size = 14,
        color = 'black',
        hjust = (1)
      ),
    legend.position = c(0.70, 0.84),
    axis.title = element_text(size = 18),
    axis.text = element_text(size = 12, color = "black"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    legend.text = element_text(size = 14),
    legend.title = element_text(size = 14)
  )
Panel_1E
```


```{r, deasratetplot, fig.cap="Rubisco不同失活程度下的下 A VS Ci", message=FALSE}
data <- read.csv("./data/RASdata.csv")
data$Ccfull <- as.numeric(data$Ccfull)
data$Deactivation <- as.factor(data$Deactivation)
print(levels(data$Deactivation))
data$Deactivation <-
  factor(data$Deactivation, levels(data$Deactivation)[c(4, 2, 3, 1)])
FigS1 <-
  ggplot(data,
         aes(
           x = Cifull,
           y = Anet,
           colour = Deactivation,
           linetype = Deactivation
         )) +
  geom_smooth(method = "loess", se = FALSE, size = 2) +
  scale_linetype_manual(
    name = "Deactivation",
    labels = c("None", "Low", "Medium", "High"),
    values = c("solid", "longdash", "dashed", "dotted")
  ) +
  labs(x = expression(C[i] ~ "(" * mu * mol ~ mol ^ {
    -1
  } * ")"),
  y = expression(A[net] ~ "(" * mu * mol ~ m ^ {
    -2
  } ~ s ^ {
    -1
  } * ")")) +
  labs(colour = 'Deactivation') +
  scale_x_continuous(limits = c(25, 100),
                     breaks = c(25, 40, 55, 70, 85, 100)) +
  scale_y_continuous(limits = c(-5, 5)) +
  geom_hline(yintercept = 0, size = 1.5) +
  theme_bw() +
  theme(
    axis.title.x = element_text(size = 20),
    axis.title.y = element_text(size = 20),
    axis.line = element_line(size = 1),
    axis.ticks = element_line(size = 1.5),
    axis.ticks.length = unit(1.5, "mm"),
    rect = element_rect(size = 2),
    axis.text.x = element_text(size = 14, color = 'black'),
    axis.text.y =
      element_text(
        size = 14,
        color = 'black',
        hjust = (1)
      ),
    legend.position = c(0.8, 0.2),
    legend.text = element_text(size = 16),
    legend.title = element_text(size = 16),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank()
  )
FigS1
```




## LI-6800 荧光数据分析 {#fluro68}

LI-6800 能够直接提供基本的叶绿素荧光参数，其他参数均可通过这些基本的参数进行计算，计算也较简单，在此不赘述，需要注意的是快相荧光部分的数据，因为分析 ojip 数据的模型有很多，很多都需要复杂的计算，在此我们先将其中较为简单的 jip test 数据分析进行介绍。

### jip test 的实现 {#jiptest}

LI-6800 增加了 ojip 曲线测量功能，本功能主要是针对测量数据的 jip test 的实现。

### `jiptest` 软件包安装 {#jiptest_pack}

目前 `jiptest` 暂时放在 github 我的软件仓库内，并没提交 CRAN，因此需要 `devtools` 的支持，然后才能从 github 安装 `jiptest`。

```{r, eval=FALSE}

install.packages("devtools")
library(devtools)
install_github("zhujiedong/jiptest")
```

### `read_files` 及 `read_dcfiles` 函数 {#readfluor}

`read_files` 用于批量读取所有调制光测量数据，方便用于其他的数据分析。**函数要求所有数据必须是 `xlsx` 格式，并且所有测量数据都保存在同一文件夹内。**，如有其他文件或测量数据则会报错。
`read_dcfiles` 用于批量读取所有连续光测量数据，其他与 `read_dcfiles` 相同。

函数仅有一个参数，即保存数据文件夹的路径，使用如下：

```{r, jipdata, message=FALSE}
library(jiptest)
jipdata <- read_files("./data/ojip")
```

```{r, echo=FALSE, message=FALSE}
knitr::kable(head(jipdata),  booktabs = TRUE,
caption = 'jiptest 批量导入数据后的样式')
```

```{r, dcjipdata, message=FALSE}
dcjipdata <- read_dcfiles("./data/ojip")
```

```{r, echo=FALSE}
knitr::kable(head(dcjipdata),  booktabs = TRUE,
caption = 'jiptest DC 数据批量导入数据后的样式')
```

### `jip_test` 及 `jip_dctest` 函数 {#testfluor}

 `jiptest` 是 jiptest 的核心函数，用于所有数据的 jip test 分析，函数仅包一个参数，测量数据的保存文件夹路径。
 `jip_dctest` 与 `jip_test` 相似，用于连续光测量数据的分析。
 
```{r, jiptest}
jip_results <- jip_test("./data/ojip")
```

```{r, jipres, echo=FALSE}
names(jip_results) <- c("parameters", "data_file1", 
                        "data_file2", "data_file3",
                        "data_file4")
knitr::kable(head(jip_results),  longtable = TRUE, booktabs = TRUE, 
             caption = 'jiptest 输出的计算参数')
```

```{r, dcjiptest, message=FALSE}
dcjip_results <- jip_dctest("./data/ojip")
```

```{r, dcjipres, echo=FALSE}
names(dcjip_results) <- c("parameters", "data_file1", 
                        "data_file2", "data_file3",
                        "data_file4")
knitr::kable(head(dcjip_results),  longtable = TRUE, booktabs = TRUE, 
             caption = 'jiptest DC 数据输出的计算参数')
```

计算参数见表 \@ref(tab:jipres) 及 \@ref(tab:dcjipres)，考虑到排版，仅显示部分内容。若需要将数据导出，可以使用相关命令，如：

```{r, eval=FALSE}
# export the results of jiptest to a csv file
write.csv(jip_results, "d:/data/jip_resluts.csv")
write.csv(dcjip_results, "d:/data/dcjip_resluts.csv")
```


### `jip_plot` 及 `jip_dcplot` 函数 {#plotfluor}

`jip_plot` 和 `jip_dcplot` 基于 `ggplot2`，用于快速预览所有测量结果的 ojip 曲线。函数仅有一个参数，即保存数据文件夹的路径，使用如下：


```{r, acplot, fig.cap="调制式测量的 ojip 曲线的快速预览", message=FALSE}
jip_plot("./data/ojip")
```

```{r, dcplot, fig.cap="连续式测量的 ojip 曲线的快速预览", message=FALSE}
jip_dcplot("./data/ojip")
```

ojip 调制式测量光 ojip 曲线的快速预览如图 \@ref(fig:acplot)

ojip 连续式测量光 ojip 曲线的快速预览如图 \@ref(fig:dcplot)

**建议在开始分析数据前，使用如上方式作图查看数据质量，若使用调制光数据测量的荧光信号太弱，数据点太散，则可以使用连续光测量信号进行分析，对于归一化的荧光参数，二者几乎无差别，当然避免陷入被动的最好方式还是最开始测量时注意检查数据质量**

\cleardoublepage
