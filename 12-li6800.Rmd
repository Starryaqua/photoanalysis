# LI-6800 的数据分析 {#anay_6800}

## 数据格式 {#data6800}

LI-6800 的数据前处理同 LI-6400 相同，如表 \@ref(tab:head6800) 所示的样式。

```{r, head6800, echo=FALSE}
style1 <- read.csv("./data/aci6800.csv")
knitr::kable(head(style1[, 1:6]),  longtable = TRUE, booktabs = TRUE, caption = '推荐 LI-6800 整理后数据样式')
```

## LI-6800 与 LI-6400 使用时的差别 {#dif}

`plantecophys` 使用时建立在 LI-6400XT 基础之上的软件包，因此在 LI-6800 代码中，需要改动的是 fitaci、fitacis 及 fitBB 中的 varnames 选项，也就是将 LI-6400XT 的表头改为 LI-6800 的表头。
以 fitaci 函数为例：

```{r, eval=FALSE}
 fitaci(aci, varnames = 
        list(ALEAF = "A", Tleaf = "Tleaf", Ci = "Ci", 
          PPFD  = "Qin", Rd = "Rd"))
```

## 光响应曲线注意事项 {#notice}

光响应曲线的拟合相对简单，仅需要光强和光合速率的值，其中需要修改的部分仅为光强的赋值部分，在文件名一致的前提下，修改如下代码即可：

```{r, eval=FALSE}
lrc_Q <- lrc$Qin
lrc_A <- lrc$A 
```

## LI-6800 RACiR\texttrademark 的测量与拟合 {#racir68}

在评估作物性状时，V$_{cmax}$ 及 J$_{max}$时非常有用，传统的 A–Ci 曲线测量要求植物叶片要在一定浓度 CO$_{2}$
下适应几分钟后完成测量，这样的测量有几个缺点：

* 测量时间长，一条曲线至少需要 20 – 30 min，样本量多，重复多时，这种方法几乎没有可行性。
* 整个测量过程中，时间长，酶的激活状态会有变化，叶绿体会移动，气孔的开度也会发生变化。

而 LI-6800 独有的 auto control 功能在算法上允许用户自定义 CO$_{2}$ 的起始浓度和种植浓度、变化方式（线性或其他）、所花费的时间，再加上其
IRGAs 极快的响应频率，使得短时间内的 A–Ci 的测量成为现实，即快速 CO$_{2}$ 响应曲线 RACiR\texttrademark
测量实验，该功能使得 5 min 内测量 A–Ci 曲线成为可能。该方法的实现可参考  @Stinziano2017
的文章。

@stinziano2018 针对 RACiR\texttrademark 技术的疑问做了解答并提出了准确测量的建议，概括如下：

* 首先，采用 100 ppm/min 的变化速率是与标准方法重合度最高的测量。
* 其次，明确研究问题，目前已有研究表明Vcmax 与 Jmax 的计算结果与标准测量方法结果无显著差异。
* 任何条件的改变，都需要做空叶室校准，例如：流速，气体浓度变化方向、温度，斜率等。
* 空叶室校准与叶片测量采用严格的同一次校准，因为 IRGA  的漂移，需要再次匹配时，或者环境条件改变时，需要重新做空叶室校准。是否需要匹配，可通过不加叶片的最初状态查看，此时 A 值应接近为0，reference 和 sample 气体浓度读数接近相等。
* IRGA 分析器使用 5 此多项式进行校准，推荐使用 1 次到 5  次多项式进行拟合，然后根据 BIC 指数来确定最合适的空叶室校准系数（即非参数拟合的模型选择的问题）。
确定最合适的浓度变化范围。通常需要去掉最初和最后 30 s的数据。
* 最小化校准和测量值之间的水分摩尔分数差异。甚至有可能需要控制 reference 或 sample 的水的摩尔分数而不是 Vpdleaf。
通过预实验来确定最合适的 $CO_2$ 变化范围和随时间的斜率。

## racir 软件包实现 RACiR\texttrademark 数据分析  {#racir_pkg}

**可能软件包作者没有更改叶面积的需求，他的软件包只支持原始数据的处理，但这对有更改需求的客户来讲没那么友好，而且这样导致了大量代码的重复，我根据作者原来的代码，结合我自己数据分析的习惯，重新制作了一份软件包，下面代码实现是基于我的软件包实现的，如有需求，也可使用作者原来的代码实现**

```{r, racir_install, eval=FALSE}
devtools::install_github("zhujiedong/racir")
library(racir)
```

软件包的函数很多，但可以分为下面几类：

* 首先使用 `find_cut` 来查看使用数据的范围（排除野点）。

* 使用 `racircheck` 来检查校正数据 (非必须，但建议进行数据质量检查)

* 使用 `racircal` 进行数据的校准

### 实现过程 {#racir_pkg_real}

手上暂时没有原始数据格式的 racir 数据，因而现在使用以前的 csv 数据进行操作（空叶室测量数据和带叶片测量数据转为 csv 格式）。

首先检查空叶室校准：

```{r, racircheck, fig.cap="找出最合理的校准曲线数据范围"}
library(racir)
# only check the empty chamber data here
em1 <- read.csv("./data/racirem/em-1.csv")
le1 <- read.csv("./data/racirle/le-1.csv")
find_cut(em1)

```

上述代码查看参比室 $CO_2$ 浓度在两者之间的数据，确定后面代码使用的 `mincut`, `maxcut` 范围。此处我选择的范围如下问代码：

```{r, racircorpkg, fig.cap="校准曲线查看"}
racircheck(em1, mincut = 21 , maxcut = 463 )
```

没有问题可直接进行校准

```{r, racircor, fig.cap="校准后数据查看"}
x <- racircal(em1, le1, mincut = 21, maxcut = 463)
plot(x$CO2_r, x$A)
```
前两个参数分别为空叶室数据，带叶片测量数据，后面的最大最小值为 `racircheck` 确定，剩余工作就是使用 `plantecophys` 进行分析，在此不再重复这个过程。

**注意：RACiR 的本意是表型研究中求 Vcmax 和 Jmax，因而，请忽略 Rd 等参数的计算结果**

### 数据的批量处理 {#racirbatch}

#### readphoto 导入 {#imbyphoto}

如果数据的导入是使用 `readphoto` 批量处理，那么所在数据文件有 files 列，作为不同文件数据的区分，那么可以使用向量化处理方式实现数据的分析，参考如下代码：

```{r, eval=FALSE}
library(readphoto)
# read all empty data set
all_empty <- read_bat_6800("./empty_data")
# read all leaf data set
all_leaf <- read_bat_6800("./leaf_data")
listem  <-  split(all_empty, files)
listle <-  split(all_leaf, files)
cordata <- purrr::map2(listem, listle, racircal, mincut = 21, maxcut = 463)
```
所有的数据均保存在 cordata 中，特别注意 **此处要求 listem 与 listle 长度相同，因此，如果一个空叶室对多个带叶片测量数据，请将空叶室测量文件复制几份（注意对应顺序），使其每个带叶片测量的数据文件和空叶室测量数据文件数量相同，并且一一对应，例如 emtpy-1-1 数据文件对应 leaf-1-1**，文件命名前即制定好命名规则，方便后续数据处理。

#### 处理大量 csv 文件 {#imbycsv}

```{r, eval=FALSE}
# suppose leaf and empty data in 2 files in disk D:
le=list.files("d:/racirle/")
em=list.files("d:/racirem/")

# construct the path of these csv files
pathle = paste0("d:/racirle/", le)
pathem = paste0("d:/racirem/", em)

# import all leaf data and empty data separately
xx <- lapply(pathle, read.csv)
yy <- lapply(pathem, read.csv)

# correct all the data
all_correc <- purrr::map2(yy, xx, racircal, mincut = 21, maxcut=463)

#  export all data to csv files, these file have the same name with leaf data
dirc <- dir.create("d:/data/")
finame <- "d:/data/"
finame <- paste0(finame, le)
purrr::walk2(all_correc,  finame, write.csv)
```

以上代码仅供参考，主要是实现批量导入并校正，在批量将校正后数据导出为 csv 文件，为方便，将导出的文件名字命名为同原来带叶片测量数据相同的文件名，。

## 批量计算 $V_{cmax}$ 和 $J_max$ {#fitbatracir}

```{r, eval=FALSE}
#use csv data above
csvdata <- lapply(all_correc, plantecophys::fitaci, 
    varnames = list(ALEAF = "A", Tleaf = "Tleaf",
    Ci = "Ci", PPFD= "Q", Rd = "Rd"), fitmethod ="bilinear")

# use readphoto data above
photodata <- lapply(cordata, plantecophys::fitaci, 
    varnames = list(ALEAF = "A", Tleaf = "Tleaf",
    Ci = "Ci", PPFD= "Q", Rd = "Rd"), fitmethod ="bilinear")
```

批量分析同样使用向量化来进行，避免了循环，效率比较高，也可以将拟合结果 `coef` 中的 $V_{cmax}$ 和 $J_max$ 结果批量导入文件，参考 @\ref(imbycsv) 部分的代码。

## RACiR\texttrademark 分析的手动实现 {#racir68_exam}

以下内容是我之前写的内容，部分代码的实现和上述软件包相似，仅供参考，尤其是当您使用 `racir` 软件包报错时，可以参考下文代码手动实现 RACiR 数据的分析。

```{r, eval=FALSE}
# 分别读取未校准空叶室数据
# 未校准带叶片测量数据
# 标准aci曲线测量数据
uemp500 <- read.csv("./data/uncorr_emp500.csv")
uleaf500 <- read.csv("./data/uncorr_leaf500.csv")
acin <- read.csv("./data/aci_ex.csv")

# 防止读入空白行
m <- length(which(uemp500$obs >= 1))
n <- length(which(uleaf500$obs >= 1))
uemp500 <- uemp500[1:m,]
uleaf500 <- uleaf500[1:n,]

# 观察空叶室未校准数据reference对A的图形
plot(uemp500$CO2_r, uemp500$A)
# 选取线性部分用于校准
locator()
# 执行locator命令后，在上图中的目标位置选点，
# 选好后按 esc 可以返回所选点的坐标（选点即为在
# 预期位置鼠标单击）

# 根据上面的点，利用二氧化碳的值过滤掉不需要的数据
# 只要在线性范围内选点，拟合结果相差很小
cemp <- uemp500[which(uemp500$CO2_r > 
                        45.28 & uemp500$CO2_r < 459.12),]
plot(cemp$CO2_r, cemp$A)

# 采用 1~5 次多项式分别拟合
cal1st <- lm(A ~ CO2_r, data = cemp)
cal2nd <- lm(A ~ poly(CO2_r, 2), data = cemp)
cal3rd <- lm(A ~ poly(CO2_r, 3), data = cemp)
cal4th <- lm(A ~ poly(CO2_r, 4), data = cemp)
cal5th <- lm(A ~ poly(CO2_r, 5), data = cemp)

# 利用 BIC 找出最合理的校准方程
bics <- BIC(cal1st, cal2nd, cal3rd, cal4th, cal5th)
# noquote也就是没引号，成为名字
best <- noquote(rownames(bics)[bics$BIC == min(bics$BIC)])
best

# 校准带叶片测量的数据
uleafc <- uleaf500
uleafc$A <- uleafc$A - predict(cal4th, uleafc)
uleafc$Ci <- ((uleafc$gtc - uleafc$E / 2) * uleafc$CO2_s - 
                uleafc$A) / (uleafc$gtc + uleafc$E / 2)

# 对校准前后的数据进行作图，查看校准效果
plot(uleaf500$CO2_r, uleaf500$A, pch = 2, ylim = c(-20, 40))
points(uleafc$CO2_r, uleafc$A)
locator()
cleaf <- uleafc[which(uleafc$CO2_r > 16.6 & 
                        uleafc$CO2_r < 478),]
plot(cleaf$CO2_r, cleaf$A)

# 利用plantecophys拟合标准曲线和racir曲线
library("plantecophys")
acifit <- fitaci(cleaf, varnames = 
                   list(ALEAF = "A", Tleaf = "Tleaf", Ci = "Ci", 
                        PPFD  = "Qin", Rd = "Rd"), Patm = 84.09)
acifit_normal <- fitaci(acin, varnames = 
                          list(ALEAF = "A", Tleaf = "Tleaf", Ci = "Ci", 
                               PPFD  = "Qin", Rd = "Rd"), Patm = 84.09)
# 查看拟合数据
acifit$pars
acifit_normal$pars

# 对快速曲线作图拟合结果进行查看
plot(acifit, linecols = c("green", "blue", "red"))

#### ggplot2 作图
ddata <- acifit$df

alldata <- data.frame(A = c(acin$A, ddata$Ac, ddata$Aj, cleaf$A), 
                      Ci = c(acin$Ci, ddata$Ci, ddata$Ci, cleaf$Ci),
                      Atype = c(
                        rep("standard Aci curve", length(acin$A)),
                        rep("Ac", length(ddata$Ac)), 
                        rep("Aj", length(ddata$Aj)),
                        rep("A corrected", length(cleaf$A))
                      )
)

alldata$Atype <- factor(alldata$Atype, 
                        levels = c("standard Aci curve", 
                                   "Ac", "Aj", "A corrected"))

library(ggplot2)
p <- ggplot(alldata)
p1 <- p + geom_point(aes(Ci,A, colour = Atype),  alpha = 0.5)

p2 <- p1 + geom_smooth(aes(Ci, A, colour = Atype),
                       method = 'auto') + 
  labs(y=expression(paste("A ", "(", mu, 
                          mol%.%m^-2%.%s^-1, ")")), 
       x=expression(paste(C[i], " ",
                          "(", mu, mol%.%mol^-1, ")")))

p2 + scale_x_continuous(limits=c(0, 1800),
                        breaks=seq(0, 1800, 200)) +  
  scale_y_continuous(limits=c(-3, 50),
                     breaks=seq(0, 50, 10)) + 
  scale_colour_hue(name="  ", 
                   labels=c('ACi curve data; ', 
                            expression(paste(A[c], ' data; ')), 
                            expression(paste(A[j], ' data; ')), 
                            'RACiR data') 
  ) + theme_set(theme_bw()) +
  theme(axis.text.x  = element_text(size = 10, 
                                    angle=30, vjust=0.5), 
        axis.text.y = element_text(size = 10),
        axis.title.x = element_text(
          size = 12, face = 'bold'),
        axis.title.y = element_text(
          size = 12, face = 'bold'),
        legend.text.align = 0,
        legend.position = c(0.8, 0.6))
```

最终采用常规方法和 RACiR\texttrademark 方法结果如图 \@ref(fig:racir) 所示，其中 Aj 与 Ac 结果采用 RACiR\texttrademark 计算^[注意，注意数据表头的大小写，此处代码中，为处理数据的方便，我更改了大小写，分析自己的数据时需要注意]。
```{r, racir, out.width='100%', fig.cap = "RACiR 方法与常规结果的比较", echo = FALSE}
knitr::include_graphics("images/racir.png")
```

## LI-6800 荧光数据分析 {#fluro68}

LI-6800 能够直接提供基本的叶绿素荧光参数，其他参数均可通过这些基本的参数进行计算，计算也较简单，在此不赘述，需要注意的是快相荧光部分的数据，因为分析 ojip 数据的模型有很多，很多都需要复杂的计算，在此我们先将其中较为简单的 jip test 数据分析进行介绍。

### jip test 的实现 {#jiptest}

LI-6800 增加了 ojip 曲线测量功能，本功能主要是针对测量数据的 jip test 的实现。

### `jiptest` 软件包安装 {#jiptest_pack}

目前 `jiptest` 暂时放在 github 我的软件仓库内，并没提交 CRAN，因此需要 `devtools` 的支持，然后才能从 github 安装 `jiptest`。

```{r, eval=FALSE}

install.packages("devtools")
library(devtools)
install_github("zhujiedong/jiptest")
```

### `read_files` 及 `read_dcfiles` 函数 {#readfluor}

`read_files` 用于批量读取所有调制光测量数据，方便用于其他的数据分析。**函数要求所有数据必须是 `xlsx` 格式，并且所有测量数据都保存在同一文件夹内。**，如有其他文件或测量数据则会报错。
`read_dcfiles` 用于批量读取所有连续光测量数据，其他与 `read_dcfiles` 相同。

函数仅有一个参数，即保存数据文件夹的路径，使用如下：

```{r, jipdata, message=FALSE}
library(jiptest)
jipdata <- read_files("./data/ojip")
```

```{r, echo=FALSE, message=FALSE}
knitr::kable(head(jipdata),  booktabs = TRUE,
caption = 'jiptest 批量导入数据后的样式')
```

```{r, dcjipdata, message=FALSE}
dcjipdata <- read_dcfiles("./data/ojip")
```

```{r, echo=FALSE}
knitr::kable(head(dcjipdata),  booktabs = TRUE,
caption = 'jiptest DC 数据批量导入数据后的样式')
```

### `jip_test` 及 `jip_dctest` 函数 {#testfluor}

 `jiptest` 是 jiptest 的核心函数，用于所有数据的 jip test 分析，函数仅包一个参数，测量数据的保存文件夹路径。
 `jip_dctest` 与 `jip_test` 相似，用于连续光测量数据的分析。
 
```{r, jiptest}
jip_results <- jip_test("./data/ojip")
```

```{r, jipres, echo=FALSE}
names(jip_results) <- c("parameters", "data_file1", 
                        "data_file2", "data_file3",
                        "data_file4")
knitr::kable(head(jip_results),  longtable = TRUE, booktabs = TRUE, 
             caption = 'jiptest 输出的计算参数')
```

```{r, dcjiptest, message=FALSE}
dcjip_results <- jip_dctest("./data/ojip")
```

```{r, dcjipres, echo=FALSE}
names(dcjip_results) <- c("parameters", "data_file1", 
                        "data_file2", "data_file3",
                        "data_file4")
knitr::kable(head(dcjip_results),  longtable = TRUE, booktabs = TRUE, 
             caption = 'jiptest DC 数据输出的计算参数')
```

计算参数见表 \@ref(tab:jipres) 及 \@ref(tab:dcjipres)，考虑到排版，仅显示部分内容。若需要将数据导出，可以使用相关命令，如：

```{r, eval=FALSE}
# export the results of jiptest to a csv file
write.csv(jip_results, "d:/data/jip_resluts.csv")
write.csv(dcjip_results, "d:/data/dcjip_resluts.csv")
```


### `jip_plot` 及 `jip_dcplot` 函数 {#plotfluor}

`jip_plot` 和 `jip_dcplot` 基于 `ggplot2`，用于快速预览所有测量结果的 ojip 曲线。函数仅有一个参数，即保存数据文件夹的路径，使用如下：


```{r, acplot, fig.cap="调制式测量的 ojip 曲线的快速预览", message=FALSE}
jip_plot("./data/ojip")
```

```{r, dcplot, fig.cap="连续式测量的 ojip 曲线的快速预览", message=FALSE}
jip_dcplot("./data/ojip")
```

ojip 调制式测量光 ojip 曲线的快速预览如图 \@ref(fig:acplot)

ojip 连续式测量光 ojip 曲线的快速预览如图 \@ref(fig:dcplot)

**建议在开始分析数据前，使用如上方式作图查看数据质量，若使用调制光数据测量的荧光信号太弱，数据点太散，则可以使用连续光测量信号进行分析，对于归一化的荧光参数，二者几乎无差别，当然避免陷入被动的最好方式还是最开始测量时注意检查数据质量**

\cleardoublepage
