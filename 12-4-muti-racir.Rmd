## 利用不同速率的 RACiR 曲线研究植物的光合生理特性 {#multirate-racir}

自 RACiR 技术诞生以来，极大的缩短了 Vcmax 以及 Jmax 的测量时间(@stinziano2017)，但也引起了一系列争议，作者也对业内的质疑进行了一一的解答 (@stinziano2018)，但除了因为时间长短导致酶活性，叶绿体位置等差异外，RACiR 还能说明哪些问题呢？@stinziano2019 最新的研究给出一系列结论：

* 扩散限制（$CO_2$ 总导度） 和光呼吸导致了表观上的标准 ACi 曲线和 RACiR 测量之间的偏差，表明他们的差异是由**生物因子引起，而非仪器导致的人为误差**。

* 上述原因导致的二者之间的偏差，如果不进行修正，那么将显著的低估 $\Gamma^*$, 除非使用多个速率的 RACiR 来修正。

* 较高速率的 RACiR 曲线会增大其与标准曲线之间的偏差，但这个差距在无光呼吸的条件下会减小。

* 因为光呼吸和气体扩散限制与物种相关，结合以上结论，可以使用多个速率的 RACiR 来估算对 $CO_2$ 的总导度以及相对量的光呼吸速率。

一些可能的方向：

* 扩散限制影响 Cc 速率的变化，说明对具有较高总阻力与 $CO_2$ 比值的物种，例如针叶物种，C4 植物，较高的阻力导致 RACiR 与 标准 ACi 测量斜率更大的差异，或者测量的前提假设被破坏。

* RACiR 可检测到代谢中 $CO_2$ 的滞后性，各种滞后性的检测对标准 ACi 测量也具有指示性。

文中利用 R 实现了光呼吸之后模型和气体扩散限制模型，本文内容主要对文献中附录材料的源码进行解释：

### 光呼吸滞后模型 {#photoresp-lag}

为测试光呼吸的滞后性，作者使用一系列预先设定的参数，模拟了一条 ACc曲线，假定 Rubisco 激活状态为 100%，并且在整个测量过程中气孔导度是不变的。然后使用这些参数来模拟 RACiRs 曲线，并且假定光呼吸分别需要 0, 15, 30, 60, 120 或 300 s 来对变化的 $CO_2$ 进行响应，在实际效果上，这意味着 Cc 在最初的 0, 15, 30, 60, 120 或 300 内是不变的，最后我们对 $\Gamma^*$ 和 Ci 使用线性回归进行计算。

#### 基础数据 {#base-data}

模型第一步，则是对需要使用的参数，根据文献和实际情况进行赋值，具体内容参考代码注释。

```{r}
library(ggplot2)
library(plyr)
library(gridExtra)

# 对图例使用自定义颜色
gg_color_hue <- function(n) {
  hues = seq(15, 375, length = n + 1)
  hcl(h = hues, l = 65, c = 100)[1:n]
}

#Maximum Rubisco carboxylation rate in umol m-2 s-1
Vcmax <- 110

#Maximum Rubisco oxygenation rate in umol m-2 s-1;
#Ratio from Bernacchi et al. 2001. PCE 24:253-259
Vomax <- 0.29 * Vcmax
#Dark respiration in umol m-2 s-1
R <- 2
#Michaelis-Menten constant for Rubisco carboxylation in umol mol-1
Kc <- 404.9
#Michaelis-Menten constant for Rubisco oxygenation in mmol mol-1
Ko <- 278.4
#oxygen concentration in mmol mol-1
O2 <- 210
Kco <- Kc * (1 + O2 / Ko)
#Boundary layer conductance in mol m-2 s-1
BLC <- 2
#stomatal conductance in mol m-2 s-1
gsw <- 0.4
#mesophyll conductance in mol m-2 s-1
gm <- 1
#Chloroplastic CO2 in umol mol-1
Cc <- as.numeric(c(25:400))
#oxygenation rate in umol m-2 s-1
vo <- Vomax * O2 / (O2 + Ko * (1 + Cc / Kc))
#carboxylation rate in umol m-2 s-1
vc <- Vcmax * (Cc) / (Cc + Kco)
#Net CO2 assimilation in umol m-2 s-1
A <- vc - 0.5 * vo - R
#Apparent CO2 assimilation rate in umol m-2 s-1
Aapparent <- vc - 0.5 * vo
#Intercellular CO2 in umol mol-1
Ci <- A / gm + Cc
#Boundary layer CO2 in umol mol-1
Cb <- A / gsw + Ci
#Reference CO2 in umol mol-1
Cr <- A / BLC + Cb

#根据Cc浓度的个数，构造向量
Counter <- as.numeric(c(1:length(Cc)))
#也就是以秒计算的cr与时间的模型
RateCrmodel <- lm(Cr ~ Counter)
#转化为分钟的cr的斜率
RateCr <- coef(RateCrmodel)[2] * 60

#转换为分钟的边界层导度斜率
RateCbmodel <- lm(Cb ~ Counter)
RateCb <- coef(RateCbmodel)[2] * 60

#转换为分钟的ci的斜率
RateCimodel <- lm(Ci ~ Counter)
RateCi <- coef(RateCimodel)[2] * 60

#转换为分钟的Cc的斜率
RateCcmodel <- lm(Cc ~ Counter)
RateCc <- coef(RateCcmodel)[2] * 60 
```

### 光呼吸滞后性代码 {code-photoresp}

下面代码的目的是为得到 ACi 响应曲线受光呼吸延迟的影响，尤其是在临近补偿点时。

**延迟模块**

```{r}
#假定有15s延迟时的数据，即相比上面构造的Cc数据减少15个点
Cc15 <- as.numeric(c((min(Cc) + 15):max(Cc), rep(max(Cc), 15)))
vo15 <- Vomax * O2 / (O2 + Ko * (1 + Cc15 / Kc))
A15 <- vc - 0.5 * vo15 - R
Aapparent15 <- vc - 0.5 * vo15

#30 s 延迟数据
Cc30 <- as.numeric(c((min(Cc) + 30):max(Cc), rep(max(Cc), 30)))
vo30 <- Vomax * O2 / (O2 + Ko * (1 + Cc30 / Kc))
A30 <- vc - 0.5 * vo30 - R
Aapparent30 <- vc - 0.5 * vo30

#60s 延迟数据
Cc60 <- as.numeric(c((min(Cc) + 60):max(Cc), rep(max(Cc), 60)))
vo60 <- Vomax * O2 / (O2 + Ko * (1 + Cc60 / Kc))
A60 <- vc - 0.5 * vo60 - R
Aapparent60 <- vc - 0.5 * vo60

#120s延迟数据
Cc120 <- as.numeric(c((min(Cc) + 120):max(Cc), rep(max(Cc), 120)))
vo120 <- Vomax * O2 / (O2 + Ko * (1 + Cc120 / Kc))
A120 <- vc - 0.5 * vo120 - R
Aapparent120 <- vc - 0.5 * vo120

#300s延迟数据
Cc300 <- as.numeric(c((min(Cc) + 300):max(Cc), rep(max(Cc), 300)))
vo300 <- Vomax * O2 / (O2 + Ko * (1 + Cc300 / Kc))
A300 <- vc - 0.5 * vo120 - R
Aapparent300 <- vc - 0.5 * vo300 
```

### 数据的构造 {#compi-modu}

下面的代码主要是将上文最终计算的数据构造数据集，并导出。

```{r}
Anet <- c(A, A15, A30, A60, A120, A300)
Aapp <-
  c(Aapparent,
    Aapparent15,
    Aapparent30,
    Aapparent60,
    Aapparent120,
    Aapparent300)
Ccfull <- rep(Cc, 6)
Cifull <- rep(Ci, 6)
Delay <-
  c(
    rep("0", length(A)),
    rep("15", length(A15)),
    rep("30", length(A30)),
    rep("60", length(A60)),
    rep("120", length(A120)),
    rep("300", length(A300))
  )
PRdata <- as.data.frame(cbind(Anet, Aapp, Ccfull, Cifull, Delay))
write.csv(PRdata, "./data/PRdata.csv")
```

### 光呼吸滞后性作图 {#photo-resp-graph}

下面的代码是将光呼吸的数据进行作图。

```{r, anetcc, fig.cap = "Anet VS. Cc", message=FALSE}
data <- read.csv("./data/PRdata.csv")
data$Ccfull <- as.numeric(data$Ccfull)
data$Delay <- as.factor(data$Delay)

# 净光合速率与Cc作图
AnetCc <- ggplot(data, aes(x = Ccfull, y = Anet, colour = Delay)) +
  geom_point() +
  labs(x = expression(C[c] ~ "(" * mu * mol ~ mol ^ {
    -1
  } * ")"),
  y = expression(A[net] ~ "(" * mu * mol ~ m ^ {
    -2
  } ~ s ^ {
    -1
  } * ")")) +
  labs(colour = 'Delay (s)') +
  scale_x_continuous(limits = c(25, 100),
                     breaks = c(25, 40, 55, 70, 85, 100)) +
  scale_y_continuous(limits = c(-5, 5)) +
  scale_colour_brewer(palette = 'Spectral') +
  #补偿点的参考线
  geom_hline(yintercept = 0) +
  theme_bw() +
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank())
AnetCc
```

```{r, anetci, fig.cap = "Anet VS. Ci", message=FALSE}
#净光合速率与Ci作图
AnetCi <- ggplot(data, aes(x = Cifull, y = Anet, colour = Delay)) +
  geom_point() +
  labs(x = expression(C[i] ~ "(" * mu * mol ~ mol ^ {
    -1
  } * ")"),
  y = expression(A[net] ~ "(" * mu * mol ~ m ^ {
    -2
  } ~ s ^ {
    -1
  } * ")")) +
  labs(colour = 'Delay (s)') +
  scale_x_continuous(limits = c(25, 100),
                     breaks = c(25, 40, 55, 70, 85, 100)) +
  scale_y_continuous(limits = c(-5, 5)) +
  scale_colour_brewer(palette = 'Spectral') +
  geom_hline(yintercept = 0) +
  theme_bw() +
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank())
AnetCi
```

```{r, aappcc, fig.cap = "Aapparent VS. Cc", message=FALSE}
#表观光合与Cc作图
AappCc <- ggplot(data, aes(x = Ccfull, y = Aapp, colour = Delay)) +
  geom_point() +
  labs(x = expression(C[c] ~ "(" * mu * mol ~ mol ^ {
    -1
  } * ")"),
  y = expression(A[apparent] ~ "(" * mu * mol ~ m ^ {
    -2
  } ~ s ^ {
    -1
  } * ")")) +
  labs(colour = 'Delay (s)') +
  scale_x_continuous(limits = c(25, 75),
                     breaks = c(25, 35, 45, 55, 65, 75)) +
  scale_y_continuous(limits = c(-5, 5)) +
  scale_colour_brewer(palette = 'Spectral') +
  geom_hline(yintercept = 0) +
  theme_bw() +
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank())
AappCc
```

```{r, aappci, fig.cap = "Aapparent VS. Ci", message=FALSE}
#表观与Ci作图
AappCi <- ggplot(data, aes(x = Cifull, y = Aapp, colour = Delay)) +
  geom_point() +
  labs(x = expression(C[i] ~ "(" * mu * mol ~ mol ^ {
    -1
  } * ")"),
  y = expression(A[apparent] ~ "(" * mu * mol ~ m ^ {
    -2
  } ~ s ^ {
    -1
  } * ")")) +
  labs(colour = 'Delay (s)') +
  scale_x_continuous(limits = c(25, 75),
                     breaks = c(25, 35, 45, 55, 65, 75)) +
  scale_y_continuous(limits = c(-5, 5)) +
  scale_colour_brewer(palette = 'Spectral') +
  geom_hline(yintercept = 0) +
  theme_bw() +
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank())
AappCi
```

### 补偿点计算 {#gammastar}

计算不同的光呼吸时间延迟下的补偿点（基于Ci）：

```{r}
#对于基于Ci的数据，仅采用ci<100时的数据
dataCi <- data[data$Cifull < 100,]
dataCi0 <- dataCi[dataCi$Delay == "0",]
dataCi15 <- dataCi[dataCi$Delay == "15",]
dataCi30 <- dataCi[dataCi$Delay == "30",]
dataCi60 <- dataCi[dataCi$Delay == "60",]
dataCi120 <- dataCi[dataCi$Delay == "120",]
dataCi300 <- dataCi[dataCi$Delay == "300",]

#光呼吸无延迟时的计算，线性拟合
m1 <- lm(dataCi0$Anet ~ dataCi0$Cifull)
summary(m1)
#补偿点为截距比斜率（纵坐标为零）
Gamma0 <- -m1$coefficients[1] / m1$coefficients[2]

#光呼吸延时15s
m2 <- lm(dataCi15$Anet ~ dataCi15$Cifull)
summary(m2)
Gamma15 <- -m2$coefficients[1] / m2$coefficients[2]

#光呼吸延时30s
m3 <- lm(dataCi30$Anet ~ dataCi30$Cifull)
summary(m3)
Gamma30 <- -m3$coefficients[1] / m3$coefficients[2]

#光呼吸延时60s
m4 <- lm(dataCi60$Anet ~ dataCi60$Cifull)
summary(m4)
Gamma60 <- -m4$coefficients[1] / m4$coefficients[2]

#光呼吸延时120s
m5 <- lm(dataCi120$Anet ~ dataCi120$Cifull)
summary(m5)
Gamma120 <- -m5$coefficients[1] / m5$coefficients[2]

#光呼吸延时300s
m6 <- lm(dataCi300$Anet ~ dataCi300$Cifull)
summary(m6)
Gamma300 <- -m6$coefficients[1] / m6$coefficients[2]
```

构造数据并作图
```{r, intdelay, fig.cap = "基于 Ci 的不同延时下的截距", message=FALSE}
GammaCi <- c(Gamma0, Gamma15, Gamma30, Gamma60, Gamma120, Gamma300)

ints <-
  c(
    m1$coefficients[1],
    m2$coefficients[1],
    m3$coefficients[1],
    m4$coefficients[1],
    m5$coefficients[1],
    m6$coefficients[1]
  )
slps <-
  c(
    0,
    m2$coefficients[2] - m1$coefficients[2],
    m3$coefficients[2] - m1$coefficients[2],
    m4$coefficients[2] - m1$coefficients[2],
    m5$coefficients[2] - m1$coefficients[2],
    m6$coefficients[2] - m1$coefficients[2]
  )
dels <- c(0, 15, 30, 60, 120, 300)
summary(lm(ints ~ dels))
plot(ints ~ dels)
```


```{r, intslps, fig.cap = "基于 Ci 的不同延时下的斜率变化", message=FALSE}
plot(slps ~ dels)
summary(lm(slps ~ dels - 1))
```

基于 Cc 的补偿点计算结果:

```{r}
# 仅使用 Cc < 75的数据点拟合，过程同ci
dataCc <- data[data$Ccfull < 75, ]
dataCc0 <- dataCc[dataCc$Delay == "0", ]
dataCc15 <- dataCc[dataCc$Delay == "15", ]
dataCc30 <- dataCc[dataCc$Delay == "30", ]
dataCc60 <- dataCc[dataCc$Delay == "60", ]
dataCc120 <- dataCc[dataCc$Delay == "120", ]
dataCc300 <- dataCc[dataCc$Delay == "300", ]

# 无延迟数据
m1 <- lm(dataCc0$Anet ~ dataCc0$Ccfull)
summary(m1)
Gamma0 <- -m1$coefficients[1] / m1$coefficients[2]

#延时15s数据
m2 <- lm(dataCc15$Anet ~ dataCc15$Ccfull)
summary(m2)
Gamma15 <- -m2$coefficients[1] / m2$coefficients[2]

#延时30s数据
m3 <- lm(dataCc30$Anet ~ dataCc30$Ccfull)
summary(m3)
Gamma30 <- -m3$coefficients[1] / m3$coefficients[2]

#延时60s数据
m4 <- lm(dataCc60$Anet ~ dataCc60$Ccfull)
summary(m4)
Gamma60 <- -m4$coefficients[1] / m4$coefficients[2]

#延时120s数据
m5 <- lm(dataCc120$Anet ~ dataCc120$Ccfull)
summary(m5)
Gamma120 <- -m5$coefficients[1] / m5$coefficients[2]

#延时300s数据
m6 <- lm(dataCc300$Anet ~ dataCc300$Ccfull)
summary(m6)
Gamma300 <- -m6$coefficients[1] / m6$coefficients[2]
```

```{r, intdelaycc, fig.cap = "基于 Cc 的不同延时下的时间", message=FALSE}
GammaCc <- c(Gamma0, Gamma15, Gamma30, Gamma60, Gamma120, Gamma300)

ints <-
  c(
    m1$coefficients[1],
    m2$coefficients[1],
    m3$coefficients[1],
    m4$coefficients[1],
    m5$coefficients[1],
    m6$coefficients[1]
  )
dels <- c(0, 15, 30, 60, 120, 300)
plot(ints ~ dels)
summary(lm(ints ~ dels))
```

```{r, slpdelaycc, fig.cap = "基于 Cc 的不同延时下的截距", message=FALSE}
#GammaStar
# For Ci-based estimates, only use Ci < 100
dataCi <- data[data$Cifull < 100,]
dataCi0 <- dataCi[dataCi$Delay == "0",]
dataCi15 <- dataCi[dataCi$Delay == "15",]
dataCi30 <- dataCi[dataCi$Delay == "30",]
dataCi60 <- dataCi[dataCi$Delay == "60",]
dataCi120 <- dataCi[dataCi$Delay == "120",]
dataCi300 <- dataCi[dataCi$Delay == "300",]
m1 <- lm(dataCi0$Aapp ~ dataCi0$Cifull)
summary(m1)
Gamma0 <- -m1$coefficients[1] / m1$coefficients[2]
m2 <- lm(dataCi15$Aapp ~ dataCi15$Cifull)
summary(m2)
Gamma15 <- -m2$coefficients[1] / m2$coefficients[2]
m3 <- lm(dataCi30$Aapp ~ dataCi30$Cifull)
summary(m3)
Gamma30 <- -m3$coefficients[1] / m3$coefficients[2]
m4 <- lm(dataCi60$Aapp ~ dataCi60$Cifull)
summary(m4)
Gamma60 <- -m4$coefficients[1] / m4$coefficients[2]
m5 <- lm(dataCi120$Aapp ~ dataCi120$Cifull)
summary(m5)
Gamma120 <- -m5$coefficients[1] / m5$coefficients[2]
m6 <- lm(dataCi300$Aapp ~ dataCi300$Cifull)
summary(m6)
Gamma300 <- -m6$coefficients[1] / m6$coefficients[2]

GammastarCi <-
  c(Gamma0, Gamma15, Gamma30, Gamma60, Gamma120, Gamma300)

# For Cc-based estimates, only use Cc < 75
dataCc <- data[data$Ccfull < 75,]
dataCc0 <- dataCc[dataCc$Delay == "0",]
dataCc15 <- dataCc[dataCc$Delay == "15",]
dataCc30 <- dataCc[dataCc$Delay == "30",]
dataCc60 <- dataCc[dataCc$Delay == "60",]
dataCc120 <- dataCc[dataCc$Delay == "120",]
dataCc300 <- dataCc[dataCc$Delay == "300",]
m1 <- lm(dataCc0$Aapp ~ dataCc0$Ccfull)
summary(m1)
Gamma0 <- -m1$coefficients[1] / m1$coefficients[2]
m2 <- lm(dataCc15$Aapp ~ dataCc15$Ccfull)
summary(m2)
Gamma15 <- -m2$coefficients[1] / m2$coefficients[2]
m3 <- lm(dataCc30$Aapp ~ dataCc30$Ccfull)
summary(m3)
Gamma30 <- -m3$coefficients[1] / m3$coefficients[2]
m4 <- lm(dataCc60$Aapp ~ dataCc60$Ccfull)
summary(m4)
Gamma60 <- -m4$coefficients[1] / m4$coefficients[2]
m5 <- lm(dataCc120$Aapp ~ dataCc120$Ccfull)
summary(m5)
Gamma120 <- -m5$coefficients[1] / m5$coefficients[2]
m6 <- lm(dataCc300$Aapp ~ dataCc300$Ccfull)
summary(m6)
Gamma300 <- -m6$coefficients[1] / m6$coefficients[2]

GammastarCc <-
  c(Gamma0, Gamma15, Gamma30, Gamma60, Gamma120, Gamma300)

Delay2 <- c("0", "15", "30", "60", "120", "300")
PRcomps <-
  as.data.frame(cbind(Delay2, GammaCc, GammaCi, GammastarCc, GammastarCi))
write.csv(PRcomps, "./data/PRcomps.csv")

ints <-
  c(
    m1$coefficients[1],
    m2$coefficients[1],
    m3$coefficients[1],
    m4$coefficients[1],
    m5$coefficients[1],
    m6$coefficients[1]
  )
dels <- c(0, 15, 30, 60, 120, 300)
summary(lm(ints ~ dels))
plot(ints ~ dels)
```

### 无光呼吸酶失活模块 {#no-phoresp-rubi}

该部分内容是在测量 ACi 曲线时检测 Rubisco 失活的影响 -- 从激活状态的变化导致了多少的偏移？

#### 数据构造 {#data-pre}

基于文献，假定 $CO_2$ 从 400 ppm 降低至 5 ppm 时，激活率从 100% 降低至 80%。

```{r}
#Assume that Rubisco activation state drops from 100% at 400 ppm to 80% at 5 ppm Cr (line 273 is Cr of 400, Cc of 297; 5ppm Cr is 25 ppm Cc) roughly from Salvucci et al 1986, arabidopsis; assume linear response

#不同的cr对应了不同的cc浓度，
#此为cc的变化范围（cr从400降低至5）
ccslope <- c(25, 297)
#酶的激活率变化
raslope <- c(0.80, 1.00)
#得到cc变化对应rubisco激活率变化的关系
ram1 <- lm(raslope ~ ccslope)
raslope <- coef(ram1)[2]
raint <- coef(ram1)[1]

#根据公式计算酶部分失活后各个参数
vora1 <- (raslope * Cc + raint) * Vomax * O2 / (O2 + Ko * (1 + Cc / Kc))
vcra1 <- (raslope * Cc + raint) * Vcmax * (Cc) / (Cc + Kco)
Ara1 <- vcra1 - 0.5 * vora1 - R
Aapparentra1 <- vcra1 - 0.5 * vora1
Cira1 <- Ara1 / gm + Cc
Cbra1 <- Ara1 / gsw + Cira1
Crra1 <- Ara1 / BLC + Cbra1

#失活后换算为分钟的变化斜率
Counter <- as.numeric(c(1:length(Cc)))
RateCr1model <- lm(Crra1 ~ Counter)
RateCr1 <- coef(RateCr1model)[2] * 60
RateCb1model <- lm(Cbra1 ~ Counter)
RateCb1 <- coef(RateCb1model)[2] * 60
RateCi1model <- lm(Cira1 ~ Counter)
RateCi1 <- coef(RateCi1model)[2] * 60
RateCcmodel <- lm(Cc ~ Counter)
RateCc <- coef(RateCcmodel)[2] * 60

#假定在5ppm时下降为40%
ccslope2 <- c(25, 297)
raslope2 <- c(0.40, 1.00)
ram2 <- lm(raslope2 ~ ccslope2)
raslope2 <- coef(ram2)[2]
raint2 <- coef(ram2)[1]

vora2 <-
  (raslope2 * Cc + raint2) * Vomax * O2 / (O2 + Ko * (1 + Cc / Kc)) 
vcra2 <- (raslope2 * Cc + raint2) * Vcmax * (Cc) / (Cc + Kco) 
Ara2 <- vcra2 - 0.5 * vora2 - R 
Aapparentra2 <- vcra2 - 0.5 * vora2 
Cira2 <- Ara2 / gm + Cc #umol mol-1
Cbra2 <- Ara2 / gsw + Cira2 #umol mol-1
Crra2 <- Ara2 / BLC + Cbra2 #umol mol-1
Counter <- as.numeric(c(1:length(Cc)))
RateCr2model <- lm(Crra2 ~ Counter)
RateCr2 <- coef(RateCr2model)[2] * 60 #umol mol-1 min-1
RateCb2model <- lm(Cbra2 ~ Counter)
RateCb2 <- coef(RateCb2model)[2] * 60 #umol mol-1 min-1
RateCi2model <- lm(Cira2 ~ Counter)
RateCi2 <- coef(RateCi2model)[2] * 60 #umol mol-1 min-1
RateCcmodel <- lm(Cc ~ Counter)
RateCc <- coef(RateCcmodel)[2] * 60 #umol mol-1 min-1

#假定在5ppm时下降为20%
ccslope3 <- c(25, 297)
raslope3 <- c(0.20, 1.00)
ram3 <- lm(raslope3 ~ ccslope3)
raslope3 <- coef(ram3)[2]
raint3 <- coef(ram3)[1]

vora3 <-
  (raslope3 * Cc + raint3) * Vomax * O2 / (O2 + Ko * (1 + Cc / Kc)) 
vcra3 <- (raslope3 * Cc + raint3) * Vcmax * (Cc) / (Cc + Kco) 
Ara3 <- vcra3 - 0.5 * vora3 - R 
Aapparentra3 <- vcra3 - 0.5 * vora3 
Cira3 <- Ara3 / gm + Cc 
Cbra3 <- Ara3 / gsw + Cira3 
Crra3 <- Ara3 / BLC + Cbra3 
Counter <- as.numeric(c(1:length(Cc)))
RateCr3model <- lm(Crra3 ~ Counter)
RateCr3 <- coef(RateCr3model)[2] * 60 
RateCb3model <- lm(Cbra3 ~ Counter)
RateCb3 <- coef(RateCb3model)[2] * 60 
RateCi3model <- lm(Cira3 ~ Counter)
RateCi3 <- coef(RateCi3model)[2] * 60 
RateCcmodel <- lm(Cc ~ Counter)
RateCc <- coef(RateCcmodel)[2] * 60 

Anet <- c(A, Ara1, Ara2, Ara3)
Aapp <- c(Aapparent, Aapparentra1, Aapparentra2, Aapparentra3)
Ccfull <- rep(Cc, 4)
Cifull <- c(Ci, Cira1, Cira2, Cira3)
Deactivation <-
  c(
    rep("None", length(A)),
    rep("Low", length(Ara1)),
    rep("Medium", length(Ara2)),
    rep("High", length(Ara3))
  )
RASdata <-
  as.data.frame(cbind(Anet, Aapp, Ccfull, Cifull, Deactivation))
write.csv(RASdata, "./data/RASdata.csv")
```

### 酶失活作图 {#Graphs-deac}

```{r, anetdeccc, fig.cap="Rubisco 不同失活程度时 Anet VS Cc", message=FALSE}
data <- read.csv("./data/RASdata.csv")
data$Ccfull <- as.numeric(data$Ccfull)
data$Deactivation <- as.factor(data$Deactivation)

AnetCc <-
  ggplot(data, aes(x = Ccfull, y = Anet, colour = Deactivation)) +
  geom_point() +
  labs(x = expression(C[c] ~ "(" * mu * mol ~ mol ^ {
    -1
  } * ")"),
  y = expression(A[net] ~ "(" * mu * mol ~ m ^ {
    -2
  } ~ s ^ {
    -1
  } * ")")) +
  labs(colour = 'Deactivation') +
  scale_x_continuous(limits = c(25, 100),
                     breaks = c(25, 40, 55, 70, 85, 100)) +
  scale_y_continuous(limits = c(-5, 5)) +
  scale_colour_brewer(palette = 'Spectral') +
  geom_hline(yintercept = 0) +
  theme_bw() +
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank())
AnetCc
```


```{r, anetdecci, fig.cap="Rubisco 不同失活程度时 Anet VS Ci", message=FALSE}
AnetCi <-
  ggplot(data, aes(x = Cifull, y = Anet, colour = Deactivation)) +
  geom_point() +
  labs(x = expression(C[i] ~ "(" * mu * mol ~ mol ^ {
    -1
  } * ")"),
  y = expression(A[net] ~ "(" * mu * mol ~ m ^ {
    -2
  } ~ s ^ {
    -1
  } * ")")) +
  labs(colour = 'Deactivation') +
  scale_x_continuous(limits = c(25, 100),
                     breaks = c(25, 40, 55, 70, 85, 100)) +
  scale_y_continuous(limits = c(-5, 5)) +
  scale_colour_brewer(palette = 'Spectral') +
  geom_hline(yintercept = 0) +
  theme_bw() +
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank())
AnetCi
```


```{r, aappdeccc, fig.cap="Rubisco 不同失活程度时 Aapp VS Cc", message=FALSE}
AappCc <-
  ggplot(data, aes(x = Ccfull, y = Aapp, colour = Deactivation)) +
  geom_point() +
  labs(x = expression(C[c] ~ "(" * mu * mol ~ mol ^ {
    -1
  } * ")"),
  y = expression(A[apparent] ~ "(" * mu * mol ~ m ^ {
    -2
  } ~ s ^ {
    -1
  } * ")")) +
  labs(colour = 'Deactivation') +
  scale_x_continuous(limits = c(25, 75),
                     breaks = c(25, 35, 45, 55, 65, 75)) +
  scale_y_continuous(limits = c(-5, 5)) +
  scale_colour_brewer(palette = 'Spectral') +
  geom_hline(yintercept = 0) +
  theme_bw() +
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank())
AappCc
```


```{r, aappdecci, fig.cap="Rubisco 不同失活程度时 Aapp VS Ci", message=FALSE}
AappCi <-
  ggplot(data, aes(x = Cifull, y = Aapp, colour = Deactivation)) +
  geom_point() +
  labs(x = expression(C[i] ~ "(" * mu * mol ~ mol ^ {
    -1
  } * ")"),
  y = expression(A[apparent] ~ "(" * mu * mol ~ m ^ {
    -2
  } ~ s ^ {
    -1
  } * ")")) +
  labs(colour = 'Deactivation') +
  scale_x_continuous(limits = c(25, 75),
                     breaks = c(25, 35, 45, 55, 65, 75)) +
  scale_y_continuous(limits = c(-5, 5)) +
  scale_colour_brewer(palette = 'Spectral') +
  geom_hline(yintercept = 0) +
  theme_bw() +
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank())
AappCi
```

### 不同失活程度下补偿点计算{#comp-est-dea}

此部分内容同未失活状态相似，不在额外介绍，可参考 \@ref(gammastar) 内容。

```{r}
#Gamma
# For Ci-based estimates, only use Ci < 100
dataCi <- data[data$Cifull < 100, ]
dataCinone <- dataCi[dataCi$Deactivation == "None", ]
dataCilow <- dataCi[dataCi$Deactivation == "Low", ]
dataCimedium <- dataCi[dataCi$Deactivation == "Medium", ]
dataCihigh <- dataCi[dataCi$Deactivation == "High", ]
m1 <- lm(dataCinone$Anet ~ dataCinone$Cifull)
summary(m1)
Gammanone <- -m1$coefficients[1] / m1$coefficients[2]
m2 <- lm(dataCilow$Anet ~ dataCilow$Cifull)
summary(m2)
Gammalow <- -m2$coefficients[1] / m2$coefficients[2]
m3 <- lm(dataCimedium$Anet ~ dataCimedium$Cifull)
summary(m3)
Gammamedium <- -m3$coefficients[1] / m3$coefficients[2]
m4 <- lm(dataCihigh$Anet ~ dataCihigh$Cifull)
summary(m4)
Gammahigh <- -m4$coefficients[1] / m4$coefficients[2]

GammaCi <- c(Gammanone, Gammalow, Gammamedium, Gammahigh)

# For Cc-based estimates, only use Cc < 75
dataCc <- data[data$Ccfull < 75, ]
dataCcnone <- dataCc[dataCc$Deactivation == "None", ]
dataCclow <- dataCc[dataCc$Deactivation == "Low", ]
dataCcmedium <- dataCc[dataCc$Deactivation == "Medium", ]
dataCchigh <- dataCc[dataCc$Deactivation == "High", ]
m1 <- lm(dataCcnone$Anet ~ dataCcnone$Ccfull)
summary(m1)
Gammanone <- -m1$coefficients[1] / m1$coefficients[2]
m2 <- lm(dataCclow$Anet ~ dataCclow$Ccfull)
summary(m2)
Gammalow <- -m2$coefficients[1] / m2$coefficients[2]
m3 <- lm(dataCcmedium$Anet ~ dataCcmedium$Ccfull)
summary(m3)
Gammamedium <- -m3$coefficients[1] / m3$coefficients[2]
m4 <- lm(dataCchigh$Anet ~ dataCchigh$Ccfull)
summary(m4)
Gammahigh <- -m4$coefficients[1] / m4$coefficients[2]

GammaCc <- c(Gammanone, Gammalow, Gammamedium, Gammahigh)

#GammaStar
# For Ci-based estimates, only use Ci < 100
dataCi <- data[data$Cifull < 100, ]
dataCinone <- dataCi[dataCi$Deactivation == "None", ]
dataCilow <- dataCi[dataCi$Deactivation == "Low", ]
dataCimedium <- dataCi[dataCi$Deactivation == "Medium", ]
dataCihigh <- dataCi[dataCi$Deactivation == "High", ]
m1 <- lm(dataCinone$Aapp ~ dataCinone$Cifull)
summary(m1)
Gammastarnone <- -m1$coefficients[1] / m1$coefficients[2]
m2 <- lm(dataCilow$Aapp ~ dataCilow$Cifull)
summary(m2)
Gammastarlow <- -m2$coefficients[1] / m2$coefficients[2]
m3 <- lm(dataCimedium$Aapp ~ dataCimedium$Cifull)
summary(m3)
Gammastarmedium <- -m3$coefficients[1] / m3$coefficients[2]
m4 <- lm(dataCihigh$Aapp ~ dataCihigh$Cifull)
summary(m4)
Gammastarhigh <- -m4$coefficients[1] / m4$coefficients[2]

GammastarCi <-
  c(Gammastarnone, Gammastarlow, Gammastarmedium, Gammastarhigh)

# For Cc-based estimates, only use Cc < 75
dataCc <- data[data$Ccfull < 75, ]
dataCcnone <- dataCc[dataCc$Deactivation == "None", ]
dataCclow <- dataCc[dataCc$Deactivation == "Low", ]
dataCcmedium <- dataCc[dataCc$Deactivation == "Medium", ]
dataCchigh <- dataCc[dataCc$Deactivation == "High", ]
m1 <- lm(dataCcnone$Aapp ~ dataCcnone$Ccfull)
summary(m1)
Gammastarnone <- -m1$coefficients[1] / m1$coefficients[2]
m2 <- lm(dataCclow$Aapp ~ dataCclow$Ccfull)
summary(m2)
Gammastarlow <- -m2$coefficients[1] / m2$coefficients[2]
m3 <- lm(dataCcmedium$Aapp ~ dataCcmedium$Ccfull)
summary(m3)
Gammastarmedium <- -m3$coefficients[1] / m3$coefficients[2]
m4 <- lm(dataCchigh$Aapp ~ dataCchigh$Ccfull)
summary(m4)
Gammastarhigh <- -m4$coefficients[1] / m4$coefficients[2]

GammastarCc <-
  c(Gammastarnone, Gammastarlow, Gammastarmedium, Gammastarhigh)

Deactivation2 <- c("None", "Low", "Medium", "High")
RAScomps <-
  as.data.frame(cbind(Deactivation2, GammaCc, GammaCi, GammastarCc, GammastarCi))
write.csv(RAScomps, "./data/RAScomps.csv")
```


## 时间延迟的扩散限制 {#diffu-limi}

对于扩散限制，下面的内容比较了多速率 RACiR 和标准 ACi 曲线的差别，比较实在有光呼吸和没有光呼吸的两种情况。对于没有扩散限制的表观光合速，采用了已知质量的碱石灰药品，放置于 1.7 ml 的微量离心管内，然后将其置于荧光叶室内部模拟叶片，此时叶室环境控制与其他实验不同，此时不再控制 H2OR。RACiR 测试从 500 到 0 的变化，不同样品的测量是随机的。

下面内容采用了一定的假设，来计算扩散的时间。

```{r}
#Equations from Campbell & Norman, 1998
#We are taking a simple approach to calculating diffusion times.
#Here we make the simplifying assumption that diffusion is pure, planar
#Diffusion, such that:
#gtot = phat * D / deltaZ
#where gtot is total conductance, phat is molar density of air in mol /m^3,
#D is diffusion coefficient in m2/s, deltaZ is pathlength in m
#Since PV = NRT, N/V = P/RT
#T in K, R in J K-1 mol-1, P in Pa

#phat = Patm/(RT)
phat = 100000 / (8.314 * 298.15)

#We also assume a linear pathlength
#Note, if diffusion is nonlinear or nonplanar, it will affect the value determined
#for D from this equation.

#D = gtot * deltaZ / phat

#Diffusion time, t, varies with D and deltaZ such that:

#t = (deltaZ)^2 / D

#So

#t = (deltaZ)^2 / (gtot * deltaZ / phat)

#If we assume mean diffusion pathlength of 1/2 lamina thickness,
#then Onoda et al. 2011 lamina thicknesses of: median 0.22 mm (0.11 to 0.74 for 95% CI)
#becomes 0.11 mm (0.055 to 0.37) for estimated deltaZ

#Convert pathlength to m
dZlow <- 0.055 / 1000
dZmedian <- 0.11 / 1000
dZhigh <- 0.37 / 1000

```

下面的内容是对边界层导度和气孔导度等赋值，由此而计算出其他所需要的参数：
```{r}
#Mesophyll Conductance
BLC <- 2 #mol m-2 s-1
gsw <- 0.4 #mol m-2 s-1

# 无限制的叶肉导度，并以此计算ci等
gm1 <- 1 #mol m-2 s-1
Ci1 <- A / gm1 + Cc #umol mol-1
Cim1 <- Ci1
Cb1 <- A / gsw + Ci1 #umol mol-1
Cr1 <- A / BLC + Cb1 #umol mol-1
#根据斜率计算达到 100 ppm min-1 时记录数据的个数
Counter <- as.numeric(c(1:length(Cc)))
RateCrmodel <- lm(Cr1 ~ Counter)
x1 <- 100 / coef(RateCrmodel)[2] 
RateCr1 <- coef(RateCrmodel)[2] * x1 #umol mol-1 min-1
#计算ci，Cc等达到100ppm min-1 时数据的个数
RateCbmodel <- lm(Cb1 ~ Counter)
RateCb1 <- coef(RateCbmodel)[2] * x1 #umol mol-1 min-1
RateCimodel <- lm(Ci1 ~ Counter)
RateCi1 <- coef(RateCimodel)[2] * x1 #umol mol-1 min-1
RateCcmodel <- lm(Cc ~ Counter)
RateCc1 <- coef(RateCcmodel)[2] * x1 #umol mol-1 min-1
#总的阻力
res1 <- 1 / gm1 + 1 / BLC + 1 / gsw

#不同的叶肉导度计算其他参数
gm2 <- 2 #mol m-2 s-1
Ci2 <- A / gm2 + Cc #umol mol-1
Cim2 <- Ci2
Cb2 <- A / gsw + Ci2 #umol mol-1
Cr2 <- A / BLC + Cb2 #umol mol-1
Counter <- as.numeric(c(1:length(Cc)))
RateCrmodel <- lm(Cr2 ~ Counter)
x2 <- 100 / coef(RateCrmodel)[2] 
RateCr2 <- coef(RateCrmodel)[2] * x2 #umol mol-1 min-1
RateCbmodel <- lm(Cb2 ~ Counter)
RateCb2 <- coef(RateCbmodel)[2] * x2 #umol mol-1 min-1
RateCimodel <- lm(Ci2 ~ Counter)
RateCi2 <- coef(RateCimodel)[2] * x2 #umol mol-1 min-1
RateCcmodel <- lm(Cc ~ Counter)
RateCc2 <- coef(RateCcmodel)[2] * x2 #umol mol-1 min-1
res2 <- 1 / gm2 + 1 / BLC + 1 / gsw

#再次计算不同导度下的数值
gm4 <- 4 #mol m-2 s-1
Ci4 <- A / gm4 + Cc #umol mol-1
Cim4 <- Ci4
Cb4 <- A / gsw + Ci4 #umol mol-1
Cr4 <- A / BLC + Cb4 #umol mol-1
Counter <- as.numeric(c(1:length(Cc)))
RateCrmodel <- lm(Cr4 ~ Counter)
x4 <- 100 / coef(RateCrmodel)[2]
RateCr4 <- coef(RateCrmodel)[2] * x4 #umol mol-1 min-1
RateCbmodel <- lm(Cb4 ~ Counter)
RateCb4 <- coef(RateCbmodel)[2] * x4 #umol mol-1 min-1
RateCimodel <- lm(Ci4 ~ Counter)
RateCi4 <- coef(RateCimodel)[2] * x4 #umol mol-1 min-1
RateCcmodel <- lm(Cc ~ Counter)
RateCc4 <- coef(RateCcmodel)[2] * x4 #umol mol-1 min-1
res4 <- 1 / gm4 + 1 / BLC + 1 / gsw

#再次计算不同导度下的数值
gm05 <- 0.5 #mol m-2 s-1
Ci05 <- A / gm05 + Cc #umol mol-1
Cim05 <- Ci05
Cb05 <- A / gsw + Ci05 #umol mol-1
Cr05 <- A / BLC + Cb05 #umol mol-1
Counter <- as.numeric(c(1:length(Cc)))
RateCrmodel <- lm(Cr05 ~ Counter)
x05 <- 100 / coef(RateCrmodel)[2]
RateCr05 <- coef(RateCrmodel)[2] * x05 #umol mol-1 min-1
RateCbmodel <- lm(Cb05 ~ Counter)
RateCb05 <- coef(RateCbmodel)[2] * x05 #umol mol-1 min-1
RateCimodel <- lm(Ci05 ~ Counter)
RateCi05 <- coef(RateCimodel)[2] * x05 #umol mol-1 min-1
RateCcmodel <- lm(Cc ~ Counter)
RateCc05 <- coef(RateCcmodel)[2] * x05 #umol mol-1 min-1
res05 <- 1 / gm05 + 1 / BLC + 1 / gsw

#正常的叶肉导度数据计算其他参数
gm025 <- 0.25 #mol m-2 s-1
Ci025 <- A / gm025 + Cc #umol mol-1
Cim025 <- Ci025
Cb025 <- A / gsw + Ci025 #umol mol-1
Cr025 <- A / BLC + Cb025 #umol mol-1
Counter <- as.numeric(c(1:length(Cc)))
RateCrmodel <- lm(Cr025 ~ Counter)
x025 <- 100 / coef(RateCrmodel)[2]
RateCr025 <- coef(RateCrmodel)[2] * x025 #umol mol-1 min-1
RateCbmodel <- lm(Cb025 ~ Counter)
RateCb025 <- coef(RateCbmodel)[2] * x025 #umol mol-1 min-1
RateCimodel <- lm(Ci025 ~ Counter)
RateCi025 <- coef(RateCimodel)[2] * x025 #umol mol-1 min-1
RateCcmodel <- lm(Cc ~ Counter)
RateCc025 <- coef(RateCcmodel)[2] * x025 #umol mol-1 min-1
res025 <- 1 / gm025 + 1 / BLC + 1 / gsw

#另一个正常的叶肉导度
gm0125 <- 0.125 #mol m-2 s-1
Ci0125 <- A / gm0125 + Cc #umol mol-1
Cim0125 <- Ci0125
Cb0125 <- A / gsw + Ci0125 #umol mol-1
Cr0125 <- A / BLC + Cb0125 #umol mol-1
Counter <- as.numeric(c(1:length(Cc)))
RateCrmodel <- lm(Cr0125 ~ Counter)
x0125 <- 100 / coef(RateCrmodel)[2]
RateCr0125 <- coef(RateCrmodel)[2] * x0125 #umol mol-1 min-1
RateCbmodel <- lm(Cb0125 ~ Counter)
RateCb0125 <- coef(RateCbmodel)[2] * x0125 #umol mol-1 min-1
RateCimodel <- lm(Ci0125 ~ Counter)
RateCi0125 <- coef(RateCimodel)[2] * x0125 #umol mol-1 min-1
RateCcmodel <- lm(Cc ~ Counter)
RateCc0125 <- coef(RateCcmodel)[2] * x0125 #umol mol-1 min-1
res0125 <- 1 / gm0125 + 1 / BLC + 1 / gsw

#利用不同叶肉导度的数据计算结果构造数据
Ratesgm <-
  c(RateCc0125, RateCc025, RateCc05, RateCc1, RateCc2, RateCc4)
gmval <- c(0.125, 0.25, 0.5, 1, 2, 4)
totalresgm <- c(res0125, res025, res05, res1, res2, res4)
resistance <-
  c(
    rep(res0125, 376),
    rep(res025, 376),
    rep(res05, 376),
    rep(res1, 376),
    rep(res2, 376),
    rep(res4, 376)
  )

#其余部分与上面类似
#此时采用不同的气孔导度构建数据
BLC <- 2 #mol m-2 s-1
gm <- 1 #mol m-2 s-1

gsw <- 0.4 #mol m-2 s-1
Ci1 <- A / gm + Cc #umol mol-1
Cis04 <- Ci1
Cb1 <- A / gsw + Ci1 #umol mol-1
Cr1 <- A / BLC + Cb1 #umol mol-1
Counter <- as.numeric(c(1:length(Cc)))
RateCrmodel <- lm(Cr1 ~ Counter)
x1 <- 100 / coef(RateCrmodel)[2] 
RateCr1 <- coef(RateCrmodel)[2] * x1 #umol mol-1 min-1
RateCbmodel <- lm(Cb1 ~ Counter)
RateCb1 <- coef(RateCbmodel)[2] * x1 #umol mol-1 min-1
RateCimodel <- lm(Ci1 ~ Counter)
RateCi1 <- coef(RateCimodel)[2] * x1 #umol mol-1 min-1
RateCcmodel <- lm(Cc ~ Counter)
RateCc04 <- coef(RateCcmodel)[2] * x1 #umol mol-1 min-1
res04 <- 1 / gm + 1 / BLC + 1 / gsw

gsw <- 0.2 #mol m-2 s-1
Ci1 <- A / gm + Cc #umol mol-1
Cis02 <- Ci1
Cb1 <- A / gsw + Ci1 #umol mol-1
Cr1 <- A / BLC + Cb1 #umol mol-1
Counter <- as.numeric(c(1:length(Cc)))
RateCrmodel <- lm(Cr1 ~ Counter)
x1 <- 100 / coef(RateCrmodel)[2]
RateCr1 <- coef(RateCrmodel)[2] * x1 #umol mol-1 min-1
RateCbmodel <- lm(Cb1 ~ Counter)
RateCb1 <- coef(RateCbmodel)[2] * x1 #umol mol-1 min-1
RateCimodel <- lm(Ci1 ~ Counter)
RateCi1 <- coef(RateCimodel)[2] * x1 #umol mol-1 min-1
RateCcmodel <- lm(Cc ~ Counter)
RateCc02 <- coef(RateCcmodel)[2] * x1 #umol mol-1 min-1
res02 <- 1 / gm + 1 / BLC + 1 / gsw

gsw <- 0.1 #mol m-2 s-1
Ci1 <- A / gm + Cc #umol mol-1
Cis01 <- Ci1
Cb1 <- A / gsw + Ci1 #umol mol-1
Cr1 <- A / BLC + Cb1 #umol mol-1
Counter <- as.numeric(c(1:length(Cc)))
RateCrmodel <- lm(Cr1 ~ Counter)
x1 <- 100 / coef(RateCrmodel)[2]
RateCr1 <- coef(RateCrmodel)[2] * x1 #umol mol-1 min-1
RateCbmodel <- lm(Cb1 ~ Counter)
RateCb1 <- coef(RateCbmodel)[2] * x1 #umol mol-1 min-1
RateCimodel <- lm(Ci1 ~ Counter)
RateCi1 <- coef(RateCimodel)[2] * x1 #umol mol-1 min-1
RateCcmodel <- lm(Cc ~ Counter)
RateCc01 <- coef(RateCcmodel)[2] * x1 #umol mol-1 min-1
res01 <- 1 / gm + 1 / BLC + 1 / gsw

gsw <- 0.05 #mol m-2 s-1
Ci1 <- A / gm + Cc #umol mol-1
Cis05 <- Ci1
Cb1 <- A / gsw + Ci1 #umol mol-1
Cr1 <- A / BLC + Cb1 #umol mol-1
Counter <- as.numeric(c(1:length(Cc)))
RateCrmodel <- lm(Cr1 ~ Counter)
x1 <- 100 / coef(RateCrmodel)[2]
RateCr1 <- coef(RateCrmodel)[2] * x1 #umol mol-1 min-1
RateCbmodel <- lm(Cb1 ~ Counter)
RateCb1 <- coef(RateCbmodel)[2] * x1 #umol mol-1 min-1
RateCimodel <- lm(Ci1 ~ Counter)
RateCi1 <- coef(RateCimodel)[2] * x1 #umol mol-1 min-1
RateCcmodel <- lm(Cc ~ Counter)
RateCc005 <- coef(RateCcmodel)[2] * x1 #umol mol-1 min-1
res005 <- 1 / gm + 1 / BLC + 1 / gsw

gsw <- 0.025 #mol m-2 s-1
Ci1 <- A / gm + Cc #umol mol-1
Cis0025 <- Ci1
Cb1 <- A / gsw + Ci1 #umol mol-1
Cr1 <- A / BLC + Cb1 #umol mol-1
Counter <- as.numeric(c(1:length(Cc)))
RateCrmodel <- lm(Cr1 ~ Counter)
x1 <- 100 / coef(RateCrmodel)[2]
RateCr1 <- coef(RateCrmodel)[2] * x1 #umol mol-1 min-1
RateCbmodel <- lm(Cb1 ~ Counter)
RateCb1 <- coef(RateCbmodel)[2] * x1 #umol mol-1 min-1
RateCimodel <- lm(Ci1 ~ Counter)
RateCi1 <- coef(RateCimodel)[2] * x1 #umol mol-1 min-1
RateCcmodel <- lm(Cc ~ Counter)
RateCc0025 <- coef(RateCcmodel)[2] * x1 #umol mol-1 min-1
res0025 <- 1 / gm + 1 / BLC + 1 / gsw

Ratesgsw <- c(RateCc0025, RateCc005, RateCc01, RateCc02, RateCc04)
gswvals <- c(0.025, 0.05, 0.1, 0.2, 0.4)
totalresgsw <- c(res0025, res005, res01, res02, res04)

# 下面的代码是采用不同的边界层导度
# 含义与上面代码相似
gm <- 1 #mol m-2 s-1
gsw <- 0.4 #mol m-2 s-1

BLC <- 2 #mol m-2 s-1

Ci1 <- A / gm + Cc #umol mol-1
Cib2 <- Ci1
Cb1 <- A / gsw + Ci1 #umol mol-1
Cr1 <- A / BLC + Cb1 #umol mol-1
Counter <- as.numeric(c(1:length(Cc)))
RateCrmodel <- lm(Cr1 ~ Counter)
x1 <- 100 / coef(RateCrmodel)[2]
RateCr1 <- coef(RateCrmodel)[2] * x1 #umol mol-1 min-1
RateCbmodel <- lm(Cb1 ~ Counter)
RateCb1 <- coef(RateCbmodel)[2] * x1 #umol mol-1 min-1
RateCimodel <- lm(Ci1 ~ Counter)
RateCi1 <- coef(RateCimodel)[2] * x1 #umol mol-1 min-1
RateCcmodel <- lm(Cc ~ Counter)
RateCc2 <- coef(RateCcmodel)[2] * x1 #umol mol-1 min-1
res2 <- 1 / gm + 1 / BLC + 1 / gsw

BLC <- 4 #mol m-2 s-1

Ci1 <- A / gm + Cc #umol mol-1
Cib4 <- Ci1
Cb1 <- A / gsw + Ci1 #umol mol-1
Cr1 <- A / BLC + Cb1 #umol mol-1
Counter <- as.numeric(c(1:length(Cc)))
RateCrmodel <- lm(Cr1 ~ Counter)
x1 <- 100 / coef(RateCrmodel)[2]
RateCr1 <- coef(RateCrmodel)[2] * x1 #umol mol-1 min-1
RateCbmodel <- lm(Cb1 ~ Counter)
RateCb1 <- coef(RateCbmodel)[2] * x1 #umol mol-1 min-1
RateCimodel <- lm(Ci1 ~ Counter)
RateCi1 <- coef(RateCimodel)[2] * x1 #umol mol-1 min-1
RateCcmodel <- lm(Cc ~ Counter)
RateCc4 <- coef(RateCcmodel)[2] * x1 #umol mol-1 min-1
res4 <- 1 / gm + 1 / BLC + 1 / gsw

BLC <- 1 #mol m-2 s-1

Ci1 <- A / gm + Cc #umol mol-1
Cib1 <- Ci1
Cb1 <- A / gsw + Ci1 #umol mol-1
Cr1 <- A / BLC + Cb1 #umol mol-1
Counter <- as.numeric(c(1:length(Cc)))
RateCrmodel <- lm(Cr1 ~ Counter)
x1 <- 100 / coef(RateCrmodel)[2]
RateCr1 <- coef(RateCrmodel)[2] * x1 #umol mol-1 min-1
RateCbmodel <- lm(Cb1 ~ Counter)
RateCb1 <- coef(RateCbmodel)[2] * x1 #umol mol-1 min-1
RateCimodel <- lm(Ci1 ~ Counter)
RateCi1 <- coef(RateCimodel)[2] * x1 #umol mol-1 min-1
RateCcmodel <- lm(Cc ~ Counter)
RateCc1 <- coef(RateCcmodel)[2] * x1 #umol mol-1 min-1
res1 <- 1 / gm + 1 / BLC + 1 / gsw

BLC <- 0.5 #mol m-2 s-1

Ci1 <- A / gm + Cc #umol mol-1
Cb1 <- A / gsw + Ci1 #umol mol-1
Cib05 <- Ci1
Cr1 <- A / BLC + Cb1 #umol mol-1
Counter <- as.numeric(c(1:length(Cc)))
RateCrmodel <- lm(Cr1 ~ Counter)
x1 <- 100 / coef(RateCrmodel)[2]
RateCr1 <- coef(RateCrmodel)[2] * x1 #umol mol-1 min-1
RateCbmodel <- lm(Cb1 ~ Counter)
RateCb1 <- coef(RateCbmodel)[2] * x1 #umol mol-1 min-1
RateCimodel <- lm(Ci1 ~ Counter)
RateCi1 <- coef(RateCimodel)[2] * x1 #umol mol-1 min-1
RateCcmodel <- lm(Cc ~ Counter)
RateCc05 <- coef(RateCcmodel)[2] * x1 #umol mol-1 min-1
res05 <- 1 / gm + 1 / BLC + 1 / gsw

BLC <- 0.25 #mol m-2 s-1

Ci1 <- A / gm + Cc #umol mol-1
Cb1 <- A / gsw + Ci1 #umol mol-1
Cib025 <- Ci1
Cr1 <- A / BLC + Cb1 #umol mol-1
Counter <- as.numeric(c(1:length(Cc)))
RateCrmodel <- lm(Cr1 ~ Counter)
x1 <- 100 / coef(RateCrmodel)[2]
RateCr1 <- coef(RateCrmodel)[2] * x1 #umol mol-1 min-1
RateCbmodel <- lm(Cb1 ~ Counter)
RateCb1 <- coef(RateCbmodel)[2] * x1 #umol mol-1 min-1
RateCimodel <- lm(Ci1 ~ Counter)
RateCi1 <- coef(RateCimodel)[2] * x1 #umol mol-1 min-1
RateCcmodel <- lm(Cc ~ Counter)
RateCc025 <- coef(RateCcmodel)[2] * x1 #umol mol-1 min-1
res025 <- 1 / gm + 1 / BLC + 1 / gsw

BLCRates <- c(RateCc025, RateCc05, RateCc1, RateCc2, RateCc4)
BLCvals <- c(0.25, 0.5, 1, 2, 4)
totalresBLC <- c(res025, res05, res1, res2, res4)

Scenario <-
  c(
    rep("Boundary Layer Conductance", 5),
    rep("Stomatal Conductance", 5),
    rep("Mesophyll Conductance", 6)
  )
Rates <- c(BLCRates, Ratesgsw, Ratesgm)
Conductances <- c(BLCvals, gswvals, gmval)
TotalRes <- c(totalresBLC, totalresgsw, totalresgm)

Cidiffusion <- c(Cim0125, Cim025, Cim05, Cim1, Cim2, Cim4)
Adiffusion <- rep(A, 6)
Aappdiffusion <- rep(Aapparent, 6)
variable <- c(rep("Mesophyll Conductance", 6 * length(Cim1)))
conductance <-
  c(rep(0.125, 376),
    rep(0.25, 376),
    rep(0.5, 376),
    rep(1, 376),
    rep(2, 376),
    rep(4, 376))


Diffusionplot <-
  as.data.frame(cbind(
    Cidiffusion,
    Adiffusion,
    Aappdiffusion,
    variable,
    conductance,
    resistance
  ))
write.csv(Diffusionplot, "./data/DiffusionLimitsACI.csv")

Diffusion <-
  as.data.frame(cbind(Scenario, Rates, Conductances, TotalRes))
write.csv(Diffusion, "./data/DiffusionLimits.csv")
```

```{r}
knitr::kable(head(Diffusion))
```


### 扩散限制滞后性 {#difu-limit}

下面的代码，是根据上面代码的计算结果，结合最初的扩散时间的公式，来计算出各个参数的最大最小值，中间值，构造数据：

```{r}
gtot1 <- 1 / res1
t1low = (dZlow) ^ 2 / (gtot1 * dZlow / phat)
t1median = (dZmedian) ^ 2 / (gtot1 * dZmedian / phat)
t1high = (dZhigh) ^ 2 / (gtot1 * dZhigh / phat)
Cc1low <- c(Cc + (t1low * RateCc1))
Cc1median <- c(Cc + (t1median * RateCc1))
Cc1high <- c(Cc + (t1high * RateCc1))
vo1low <- Vomax * O2 / (O2 + Ko * (1 + Cc1low / Kc)) 
A1low <- vc - 0.5 * vo1low - R 
vo1median <- Vomax * O2 / (O2 + Ko * (1 + Cc1median / Kc)) 
A1median <- vc - 0.5 * vo1median - R 
vo1high <- Vomax * O2 / (O2 + Ko * (1 + Cc1high / Kc)) 
A1high <- vc - 0.5 * vo1high - R 

gtot0125 <- 1 / res0125
t0125low = (dZlow) ^ 2 / (gtot0125 * dZlow / phat)
t0125median = (dZmedian) ^ 2 / (gtot0125 * dZmedian / phat)
t0125high = (dZhigh) ^ 2 / (gtot0125 * dZhigh / phat)
Cc0125low <- c(Cc + (t0125low * RateCc0125))
Cc0125median <- c(Cc + (t0125median * RateCc0125))
Cc0125high <- c(Cc + (t0125high * RateCc0125))
vo0125low <- Vomax * O2 / (O2 + Ko * (1 + Cc0125low / Kc)) 
A0125low <- vc - 0.5 * vo0125low - R 
vo0125median <- Vomax * O2 / (O2 + Ko * (1 + Cc0125median / Kc)) 
A0125median <- vc - 0.5 * vo0125median - R 
vo0125high <- Vomax * O2 / (O2 + Ko * (1 + Cc0125high / Kc)) 
A0125high <- vc - 0.5 * vo0125high - R 

gtot025 <- 1 / res025
t025low = (dZlow) ^ 2 / (gtot025 * dZlow / phat)
t025median = (dZmedian) ^ 2 / (gtot025 * dZmedian / phat)
t025high = (dZhigh) ^ 2 / (gtot025 * dZhigh / phat)
Cc025low <- c(Cc + (t025low * RateCc025))
Cc025median <- c(Cc + (t025median * RateCc025))
Cc025high <- c(Cc + (t025high * RateCc025))
vo025low <- Vomax * O2 / (O2 + Ko * (1 + Cc025low / Kc)) 
A025low <- vc - 0.5 * vo025low - R 
vo025median <- Vomax * O2 / (O2 + Ko * (1 + Cc025median / Kc)) 
A025median <- vc - 0.5 * vo025median - R 
vo025high <- Vomax * O2 / (O2 + Ko * (1 + Cc025high / Kc)) 
A025high <- vc - 0.5 * vo025high - R 

gtot05 <- 1 / res05
t05low = (dZlow) ^ 2 / (gtot05 * dZlow / phat)
t05median = (dZmedian) ^ 2 / (gtot05 * dZmedian / phat)
t05high = (dZhigh) ^ 2 / (gtot05 * dZhigh / phat)
Cc05low <- c(Cc + (t05low * RateCc05))
Cc05median <- c(Cc + (t05median * RateCc05))
Cc05high <- c(Cc + (t05high * RateCc05))
vo05low <- Vomax * O2 / (O2 + Ko * (1 + Cc05low / Kc)) 
A05low <- vc - 0.5 * vo05low - R 
vo05median <- Vomax * O2 / (O2 + Ko * (1 + Cc05median / Kc)) 
A05median <- vc - 0.5 * vo05median - R 
vo05high <- Vomax * O2 / (O2 + Ko * (1 + Cc05high / Kc)) 
A05high <- vc - 0.5 * vo05high - R 

gtot2 <- 1 / res2
t2low = (dZlow) ^ 2 / (gtot2 * dZlow / phat)
t2median = (dZmedian) ^ 2 / (gtot2 * dZmedian / phat)
t2high = (dZhigh) ^ 2 / (gtot2 * dZhigh / phat)
Cc2low <- c(Cc + (t2low * RateCc2))
Cc2median <- c(Cc + (t2median * RateCc2))
Cc2high <- c(Cc + (t2high * RateCc2))
vo2low <- Vomax * O2 / (O2 + Ko * (1 + Cc2low / Kc)) 
A2low <- vc - 0.5 * vo2low - R 
vo2median <- Vomax * O2 / (O2 + Ko * (1 + Cc2median / Kc)) 
A2median <- vc - 0.5 * vo2median - R 
vo2high <- Vomax * O2 / (O2 + Ko * (1 + Cc2high / Kc)) 
A2high <- vc - 0.5 * vo2high - R 

gtot4 <- 1 / res4
t4low = (dZlow) ^ 2 / (gtot4 * dZlow / phat)
t4median = (dZmedian) ^ 2 / (gtot4 * dZmedian / phat)
t4high = (dZhigh) ^ 2 / (gtot4 * dZhigh / phat)
Cc4low <- c(Cc + (t4low * RateCc4))
Cc4median <- c(Cc + (t4median * RateCc4))
Cc4high <- c(Cc + (t4high * RateCc4))
vo4low <- Vomax * O2 / (O2 + Ko * (1 + Cc4low / Kc)) 
A4low <- vc - 0.5 * vo4low - R 
vo4median <- Vomax * O2 / (O2 + Ko * (1 + Cc4median / Kc)) 
A4median <- vc - 0.5 * vo4median - R 
vo4high <- Vomax * O2 / (O2 + Ko * (1 + Cc4high / Kc)) 
A4high <- vc - 0.5 * vo4high - R 

Cc0125high2 <- c(Cc + (t0125high * RateCc0125 * 2))
Cc025high2 <- c(Cc + (t025high * RateCc025 * 2))
Cc05high2 <- c(Cc + (t05high * RateCc05 * 2))
Cc1high2 <- c(Cc + (t1high * RateCc1 * 2))
Cc2high2 <- c(Cc + (t2high * RateCc2 * 2))
Cc4high2 <- c(Cc + (t4high * RateCc4 * 2))

vo0125high2 <- Vomax * O2 / (O2 + Ko * (1 + Cc0125high2 / Kc)) 
A0125high2 <- vc - 0.5 * vo0125high2 - R 
vo025high2 <- Vomax * O2 / (O2 + Ko * (1 + Cc025high2 / Kc)) 
A025high2 <- vc - 0.5 * vo025high2 - R 
vo05high2 <- Vomax * O2 / (O2 + Ko * (1 + Cc05high2 / Kc)) 
A05high2 <- vc - 0.5 * vo05high2 - R 
vo1high2 <- Vomax * O2 / (O2 + Ko * (1 + Cc1high2 / Kc)) 
A1high2 <- vc - 0.5 * vo1high2 - R 
vo2high2 <- Vomax * O2 / (O2 + Ko * (1 + Cc2high2 / Kc)) 
A2high2 <- vc - 0.5 * vo2high2 - R 
vo4high2 <- Vomax * O2 / (O2 + Ko * (1 + Cc4high2 / Kc)) 
A4high2 <- vc - 0.5 * vo4high2 - R 

Ahigh2 <-
  c(A0125high2, A025high2, A05high2, A1high2, A2high2, A4high2)

Cc0125high3 <- c(Cc + (t0125high * RateCc0125 * 3))
Cc025high3 <- c(Cc + (t025high * RateCc025 * 3))
Cc05high3 <- c(Cc + (t05high * RateCc05 * 3))
Cc1high3 <- c(Cc + (t1high * RateCc1 * 3))
Cc2high3 <- c(Cc + (t2high * RateCc2 * 3))
Cc4high3 <- c(Cc + (t4high * RateCc4 * 3))

vo0125high3 <- Vomax * O2 / (O2 + Ko * (1 + Cc0125high3 / Kc)) 
A0125high3 <- vc - 0.5 * vo0125high3 - R 
vo025high3 <- Vomax * O2 / (O2 + Ko * (1 + Cc025high3 / Kc)) 
A025high3 <- vc - 0.5 * vo025high3 - R 
vo05high3 <- Vomax * O2 / (O2 + Ko * (1 + Cc05high3 / Kc)) 
A05high3 <- vc - 0.5 * vo05high3 - R 
vo1high3 <- Vomax * O2 / (O2 + Ko * (1 + Cc1high3 / Kc)) 
A1high3 <- vc - 0.5 * vo1high3 - R 
vo2high3 <- Vomax * O2 / (O2 + Ko * (1 + Cc2high3 / Kc)) 
A2high3 <- vc - 0.5 * vo2high3 - R 
vo4high3 <- Vomax * O2 / (O2 + Ko * (1 + Cc4high3 / Kc)) 
A4high3 <- vc - 0.5 * vo4high3 - R 

Ahigh3 <-
  c(A0125high3, A025high3, A05high3, A1high3, A2high3, A4high3)

Cidiffusion <- c(Cim0125, Cim025, Cim05, Cim1, Cim2, Cim4)
Alow <- c(A0125low, A025low, A05low, A1low, A2low, A4low)
Amedian <-
  c(A0125median,
    A025median,
    A05median,
    A1median,
    A2median,
    A4median)
Ahigh <- c(A0125high, A025high, A05high, A1high, A2high, A4high)

variable <- c(rep("Mesophyll Conductance", 6 * length(Cim1)))
conductance <-
  c(rep(0.125, 376),
    rep(0.25, 376),
    rep(0.5, 376),
    rep(1, 376),
    rep(2, 376),
    rep(4, 376))

Diffusionplot2 <-
  as.data.frame(
    cbind(
      Cidiffusion,
      Alow,
      Amedian,
      Ahigh,
      Ahigh2,
      Ahigh3,
      variable,
      conductance,
      resistance
    )
  )
write.csv(Diffusionplot2, "./data/DiffusionLimitsACI2.csv")
```

最终够到的不同导度下的扩散数据如下：

```{r}
knitr::kable(head(Diffusionplot2))
```


## 扩散限制作图 {#difu-graph}

```{r,difuci, fig.cap="不同 Ci 扩散限制下的差异", message=FALSE}
data <- read.csv("./data/DiffusionLimitsACI2.csv")
data$resistance <- as.factor(data$resistance)
graph <- ggplot(data, aes(x = Cidiffusion, y = Ahigh3, colour = resistance)) +
  geom_abline(slope=0,intercept=0,size=1.5)+
  geom_point()+
  labs(colour = 'Total Resistance')+
  scale_colour_brewer(palette = 'Spectral') +
  theme_bw() +
  scale_x_continuous(limits=c(0,100))+
  scale_y_continuous(limits=c(-5,10))+
  theme(
    axis.title = element_text(size = 18),
    axis.text = element_text(size = 15),
    legend.position = 'right',
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank()
  )
graph
```


```{r, difuci11, fig.cap="不同 Ci 扩散限制下的差异（resistance = 11）", message=FALSE}
datahigh <- data[data$resistance == "11",]
graph <- ggplot(datahigh, aes(x = Cidiffusion, y = Ahigh3)) +
  geom_abline(slope=0,intercept=0,size=1.5)+
  geom_point(colour = "red")+
  geom_point(aes(x = Cidiffusion, y = Ahigh2), colour = "blue")+
  geom_point(aes(x = Cidiffusion, y = Ahigh), colour = "green")+
  labs(colour = 'Total Resistance')+
  scale_colour_brewer(palette = 'Spectral') +
  theme_bw() +
  scale_x_continuous(limits=c(0,100))+
  scale_y_continuous(limits=c(-2.5,2.5))+
  theme(
    axis.title = element_text(size = 18),
    axis.text = element_text(size = 15),
    legend.position = 'right',
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank()
  )
graph
```


```{r, tolresis, fig.cap="不同总导度下的各个导度的速率变化", message=FALSE}
data2 <- read.csv("./data/DiffusionLimits.csv")
graph <- ggplot(data2, aes(x = TotalRes, y = Rates, colour = Scenario)) +
  geom_point()+
  scale_colour_brewer(palette = 'Spectral') +
  theme_bw() +
  theme(
    axis.title = element_text(size = 18),
    axis.text = element_text(size = 12),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank()
  )
graph
```


```{r, tolre, fig.cap="不同阻力下的各个导度的速率变化预测值", message=FALSE}
m1 <- lm(Rates ~ I(1/TotalRes)+I((1/TotalRes)^2),data=data2)
summary(m1)
ab <- predict(m1)
red <- 1/data2$TotalRes
plot(ab~red)
```

### 补偿点的计算 {#compen-estimate}

计算补偿点，代码同前文类似，只是采用了不同导度下的数值：

```{r}
data <- read.csv("./data/DiffusionLimitsACI2.csv")
#Gamma
# For Ci-based estimates, only use Ci < 100
dataCi <- data[data$Cidiffusion < 100, ]
dataCi0125 <- dataCi[dataCi$conductance == "0.125", ]
dataCi025 <- dataCi[dataCi$conductance == "0.25", ]
dataCi05 <- dataCi[dataCi$conductance == "0.5", ]
dataCi1 <- dataCi[dataCi$conductance == "1", ]
dataCi2 <- dataCi[dataCi$conductance == "2", ]
dataCi4 <- dataCi[dataCi$conductance == "4", ]
m1 <- lm(dataCi0125$Ahigh ~ dataCi0125$Cidiffusion)
summary(m1)
Gamma0125 <- -m1$coefficients[1] / m1$coefficients[2]
m2 <- lm(dataCi025$Ahigh ~ dataCi025$Cidiffusion)
summary(m2)
Gamma025 <- -m2$coefficients[1] / m2$coefficients[2]
m3 <- lm(dataCi05$Ahigh ~ dataCi05$Cidiffusion)
summary(m3)
Gamma05 <- -m3$coefficients[1] / m3$coefficients[2]
m4 <- lm(dataCi1$Ahigh ~ dataCi1$Cidiffusion)
summary(m4)
Gamma1 <- -m4$coefficients[1] / m4$coefficients[2]
m5 <- lm(dataCi2$Ahigh ~ dataCi2$Cidiffusion)
summary(m5)
Gamma2 <- -m5$coefficients[1] / m5$coefficients[2]
m6 <- lm(dataCi4$Ahigh ~ dataCi4$Cidiffusion)
summary(m6)
Gamma4 <- -m6$coefficients[1] / m6$coefficients[2]

GammaCi <- c(Gamma0125, Gamma025, Gamma05, Gamma1, Gamma2, Gamma4)
```

### 所有图形代码 {#all-fig}


```{r, prdataplot, fig.cap="不同时间滞后性的 Anet VS Ci", message=FALSE}
data <- read.csv("./data/PRdata.csv")
data$Ccfull <- as.numeric(data$Ccfull)
data$Delay <- as.factor(data$Delay)
cols <- gg_color_hue(6)
Panel_1A <-
  ggplot(data, aes(
    x = Cifull,
    y = Anet,
    colour = Delay,
    linetype = Delay
  )) +
  # 零水平参考线
  geom_abline(slope = 0,
              intercept = 0,
              size = 1.5) +
  #ci与A loess 方法的拟合曲线
  geom_smooth(method = "loess", se = FALSE, size = 2) +
  scale_linetype_manual(
    name = "Delay (s)",
    labels = c("0", "15", "30", "60", "120", "300"),
    values = c("solid", "longdash", "twodash", "dotdash", "dashed", "dotted")
  ) +
  ggtitle(expression(paste(
    bold("(a)"), " Modelled Photorespiratory Effect"
  ))) +
  labs(x = expression(C[i] ~ "(" * mu * mol ~ mol ^ {
    -1
  } * ")"),
  y = expression(A[net] ~ "(" * mu * mol ~ m ^ {
    -2
  } ~ s ^ {
    -1
  } * ")")) +
  labs(colour = 'Delay (s)') +
  scale_x_continuous(limits = c(0, 250)) +
  scale_y_continuous(limits = c(-5, 20)) +
  scale_colour_manual(
    values = cols,
    name = "Delay (s)",
    labels = c("0", "15", "30", "60", "120", "300")
  ) +
  theme_bw() +
  theme(
    axis.title.x = element_text(size = 20),
    axis.title.y = element_text(size = 20),
    axis.line = element_line(size = 1),
    axis.ticks = element_line(size = 1.5),
    axis.ticks.length = unit(1.5, "mm"),
    rect = element_rect(size = 2),
    axis.text.x = element_text(size = 14, color = 'black'),
    axis.text.y =
      element_text(
        size = 14,
        color = 'black',
        hjust = (1)
      ),
    legend.position = c(0.15, 0.75),
    axis.title = element_text(size = 18),
    axis.text = element_text(size = 12, color = "black"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    legend.text = element_text(size = 14),
    legend.title = element_text(size = 14)
  )
Panel_1A
```


```{r, resistplot, fig.cap="不同总阻力下的 Anet VS Ci", message=FALSE}
Panel_1A_inset <-
  ggplot(data, aes(
    x = Cifull,
    y = Anet,
    colour = Delay,
    linetype = Delay
  )) +
  geom_abline(slope = 0,
              intercept = 0,
              size = 1.5) +
  geom_smooth(method = "loess", se = FALSE, size = 2) +
  scale_linetype_manual(
    name = "Delay (s)",
    labels = c("0", "15", "30", "60", "120", "300"),
    values = c("solid", "longdash", "twodash", "dotdash", "dashed", "dotted")
  ) +
  labs(x = expression(C[i] ~ "(" * mu * mol ~ mol ^ {
    -1
  } * ")"),
  y = expression(A[net] ~ "(" * mu * mol ~ m ^ {
    -2
  } ~ s ^ {
    -1
  } * ")")) +
  labs(colour = 'Delay (s)') +
  scale_x_continuous(limits = c(45, 65)) +
  scale_y_continuous(limits = c(-1, 1), breaks = c(-1, 0, 1)) +
  scale_colour_manual(values = cols) +
  theme_bw() +
  theme(
    axis.title.x = element_blank(),
    axis.title.y = element_blank(),
    axis.line = element_line(size = 1),
    axis.ticks = element_line(size = 1.5),
    axis.ticks.length = unit(1.5, "mm"),
    rect = element_rect(size = 2),
    axis.text.x = element_text(size = 14, color = 'black'),
    axis.text.y =
      element_text(
        size = 14,
        color = 'black',
        hjust = (1)
      ),
    axis.title = element_blank(),
    axis.text = element_text(size = 12, color = "black"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    legend.position = 'none',
    plot.background = element_blank()
  )



cols <- gg_color_hue(6)

data <- read.csv("./data/DiffusionLimitsACI2.csv")
data$resistance <- as.factor(data$resistance)
Panel_1Db <-
  ggplot(data,
         aes(
           x = Cidiffusion,
           y = Ahigh,
           colour = resistance,
           linetype = resistance
         )) +
  geom_abline(slope = 0,
              intercept = 0,
              size = 1.5) +
  geom_smooth(method = "loess", se = FALSE, size = 2) +
  scale_linetype_manual(
    name = "Total Resistance",
    labels = c("3.25", "3.5", "4", "5", "7", "11"),
    values = c("solid", "longdash", "twodash", "dotdash", "dashed", "dotted")
  ) +
  ggtitle(expression(paste(bold("(d)"), " Modelled Resistance Effect"))) +
  scale_color_manual(
    values = cols,
    name = "Total Resistance",
    labels = c("3.25", "3.5", "4", "5", "7", "11")
  ) +
  theme_bw() +
  labs(x = expression(paste(C[i] ~ "(" * mu * mol ~ mol ^ {
    -1
  } * ")")), y = expression(paste(A[net] ~ "(" * mu * mol ~ m ^ {
    -2
  } ~ s ^ {
    -1
  } * ")"))) +
  scale_x_continuous(limits = c(0, 250)) +
  scale_y_continuous(limits = c(-5, 20)) +
  theme(
    axis.title.x = element_text(size = 20),
    axis.title.y = element_text(size = 20),
    axis.line = element_line(size = 1),
    axis.ticks = element_line(size = 1.5),
    axis.ticks.length = unit(1.5, "mm"),
    rect = element_rect(size = 2),
    axis.text.x = element_text(size = 14, color = 'black'),
    axis.text.y =
      element_text(
        size = 14,
        color = 'black',
        hjust = (1)
      ),
    legend.position = c(0.22, 0.75),
    axis.title = element_text(size = 18),
    axis.text = element_text(size = 12, color = "black"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    legend.text = element_text(size = 14),
    legend.title = element_text(size = 14)
  )
Panel_1Db
```


```{r, high3tplot, fig.cap="不同导度下的 A VS Ci", message=FALSE}
data <- read.csv("./data/DiffusionLimitsACI2.csv")
data$resistance <- as.factor(data$resistance)
data <- data[data$resistance == "11",]
resistance <- rep(data$resistance, 3)
Cidiffusion <- rep(data$Cidffusion, 3)
A <- c(data$Ahigh, data$Ahigh2, data$Ahigh3)
Rate <-
  c(rep(100, length(data$Ahigh)), rep(200, length(data$Ahigh2)), rep(300, length(data$Ahigh3)))
data3 <- rbind(data, data, data)
data3$A <- c(data$Ahigh, data$Ahigh2, data$Ahigh3)
data3$Rate <-
  as.factor(c(rep(100, length(data$Ahigh)), rep(200, length(data$Ahigh2)), rep(300, length(data$Ahigh3))))
Panel_1Dbinset <-
  ggplot(data3, aes(
    x = Cidiffusion,
    y = A,
    colour = Rate,
    linetype = Rate
  )) +
  geom_abline(slope = 0,
              intercept = 0,
              size = 1.5) +
  geom_smooth(method = "loess", se = FALSE, size = 2) +
  scale_linetype_manual(
    name = "Rate",
    labels = c("100", "200", "300"),
    values = c("solid", "longdash", "twodash")
  ) +
  scale_color_manual(
    values = cols,
    name = "Rate",
    labels = c("100", "200", "300")
  ) +
  theme_bw() +
  labs(x = expression(paste(C[i] ~ "(" * mu * mol ~ mol ^ {
    -1
  } * ")")), y = expression(paste(A[net] ~ "(" * mu * mol ~ m ^ {
    -2
  } ~ s ^ {
    -1
  } * ")"))) +
  scale_x_continuous(limits = c(45, 65)) +
  scale_y_continuous(limits = c(-1, 1), breaks = c(-1, 0, 1)) +
  theme(
    axis.title.x = element_blank(),
    axis.title.y = element_blank(),
    axis.line = element_line(size = 1),
    axis.ticks = element_line(size = 1.5),
    axis.ticks.length = unit(1.5, "mm"),
    rect = element_rect(size = 2),
    axis.text.x = element_text(size = 14, color = 'black'),
    axis.text.y =
      element_text(
        size = 14,
        color = 'black',
        hjust = (1)
      ),
    legend.position = c(0.22, 0.75),
    axis.title = element_text(size = 18),
    axis.text = element_text(size = 12, color = "black"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    plot.background = element_blank(),
    legend.text = element_text(size = 12),
    legend.key = element_blank(),
    legend.title = element_blank(),
    legend.background = element_blank()
  )
Panel_1Dbinset
```


```{r, toresratetplot, fig.cap="不同总导度下的各个导度的变化", message=FALSE}
data2 <- read.csv("./data/DiffusionLimits.csv")
data2$Conductance <-
  revalue(
    data2$Scenario,
    c(
      "Boundary Layer Conductance" = "Boundary Layer",
      "Mesophyll Conductance" = "Mesophyll",
      "Stomatal Conductance" = "Stomatal"
    )
  )
cols <- gg_color_hue(3)

Panel_1E <-
  ggplot(data2, aes(x = TotalRes, y = Rates, colour = Conductance)) +
  geom_point(size = 4) +
  ggtitle(expression(paste(bold("(e)"), " Modelled Resistance Effect"))) +
  labs(x = expression(paste(r[total] * " (s" ~ m ^ {
    2
  } ~ mol ^ {
    -1
  } * ")")), 
  y = expression(paste(C[c] * " Ramp Rate (" * mu * mol ~ mol ^
                                    {
                                      -1
                                    } ~ min ^ {
                                      -1
                                    } * ")"))) +
  scale_x_continuous(limits = c(0, 50)) +
  scale_y_continuous(limits = c(0, 80)) +
  scale_color_manual(
    values = cols,
    name = "Manipulated Resistance",
    labels = c("Boundary Layer", "Mesophyll", "Stomatal")
  ) +
  theme_bw() +
  theme(
    axis.title.x = element_text(size = 20),
    axis.title.y = element_text(size = 20),
    axis.line = element_line(size = 1),
    axis.ticks = element_line(size = 1.5),
    axis.ticks.length = unit(1.5, "mm"),
    rect = element_rect(size = 2),
    axis.text.x = element_text(size = 14, color = 'black'),
    axis.text.y =
      element_text(
        size = 14,
        color = 'black',
        hjust = (1)
      ),
    legend.position = c(0.70, 0.84),
    axis.title = element_text(size = 18),
    axis.text = element_text(size = 12, color = "black"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    legend.text = element_text(size = 14),
    legend.title = element_text(size = 14)
  )
Panel_1E
```


```{r, deasratetplot, fig.cap="Rubisco不同失活程度下的下 A VS Ci", message=FALSE}
data <- read.csv("./data/RASdata.csv")
data$Ccfull <- as.numeric(data$Ccfull)
data$Deactivation <- as.factor(data$Deactivation)
print(levels(data$Deactivation))
data$Deactivation <-
  factor(data$Deactivation, levels(data$Deactivation)[c(4, 2, 3, 1)])
FigS1 <-
  ggplot(data,
         aes(
           x = Cifull,
           y = Anet,
           colour = Deactivation,
           linetype = Deactivation
         )) +
  geom_smooth(method = "loess", se = FALSE, size = 2) +
  scale_linetype_manual(
    name = "Deactivation",
    labels = c("None", "Low", "Medium", "High"),
    values = c("solid", "longdash", "dashed", "dotted")
  ) +
  labs(x = expression(C[i] ~ "(" * mu * mol ~ mol ^ {
    -1
  } * ")"),
  y = expression(A[net] ~ "(" * mu * mol ~ m ^ {
    -2
  } ~ s ^ {
    -1
  } * ")")) +
  labs(colour = 'Deactivation') +
  scale_x_continuous(limits = c(25, 100),
                     breaks = c(25, 40, 55, 70, 85, 100)) +
  scale_y_continuous(limits = c(-5, 5)) +
  geom_hline(yintercept = 0, size = 1.5) +
  theme_bw() +
  theme(
    axis.title.x = element_text(size = 20),
    axis.title.y = element_text(size = 20),
    axis.line = element_line(size = 1),
    axis.ticks = element_line(size = 1.5),
    axis.ticks.length = unit(1.5, "mm"),
    rect = element_rect(size = 2),
    axis.text.x = element_text(size = 14, color = 'black'),
    axis.text.y =
      element_text(
        size = 14,
        color = 'black',
        hjust = (1)
      ),
    legend.position = c(0.8, 0.2),
    legend.text = element_text(size = 16),
    legend.title = element_text(size = 16),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank()
  )
FigS1
```


\cleardoublepage